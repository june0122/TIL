# Chapter13. 포인터와 배열, 함께 이해하기

### 포인터와 배열의 관계

> 배열의 이름은 무엇을 의미하는가?

배열의 이름은 포인터이다. 단, 그 값을 바꿀 수 없는 '상수 형태의 포인터'이다. 다음 예제에서는 이러한 사실을 증명하고 있다.

```c
1 #include <stdio.h>
2
3 int main(void)
4 {
5   int arr[3]={0, 1, 2};
6   printf("배열의 이름: %p \n", arr);
7   printf("첫 번째 요소: %p \n", &arr[0]);
8   printf("두 번째 요소: %p \n", &arr[1]);
9   printf("세 번째 요소: %p \n", &arr[2]);
10   // arr = &arr[i];  //  이 문장은 컴파일 에러를 일으킨다.
11   return 0;
12 }

// 7 행에서 printf("첫 번째 요소: %d \n", arr[0]); 로 변경하면 주소값이 아닌 0이 결과로 나온다.
```

```
배열의 이름: 0x7ffc50295eac
첫 번째 요소: 0x7ffc50295eac
두 번째 요소: 0x7ffc50295eb0
세 번째 요소: 0x7ffc50295eb4
```

위의 실행결과가 우리에게 시사하는 바가 크다. 먼저 위의 실행결과를 통해서 우리는 다음 사실을 알 수 있다.

**int형 배열요소간 주소 값의 차는 4바이트이다.**

코드에서 선언한 배열이 int형 배열이므로 각 요소 별로 할당되는 메모리 공간의 크기는 4바이트이다. 따라서 배열 요소간 주소 값의 차가 4바이트임을 보이는 위의 실행결과는 `모든 배열요소가 메모리 공간에 나란히 할당된다`라는 사실을 증명하는 결과가 된다.

그리고 첫 번째 바이트 주소 값 `&arr[0]`과 `배열의 이름`을 출력한 결과가 같다는 사실을 확인할 수 있다.

게다가 예제 10행에서 보이듯, 배열의 이름은 대입 연산자의 피연산자가 될 수 없으므로 **배열의 이름은 배열의 시작 주소 값을 의미하며, 그 형태는 값의 저장이 불가능한 상수이다.** 라는 결론을 내릴 수 있다.

<br>

| 포인터 변수와 배열의 이름 비교

|비교조건＼비교대상|포인터 변수|배열의 이름|
|---|---|---|
|이름이 존재하는가?   |존재한다   |존재한다   |
|무엇을 나타내거나 저장하는가?   |메모리의 주소 값   |메모리의 주소 값   |
|주소 값의 변경이 가능한가?   |가능하다   |**불가능하다**   |

즉 배열의 이름은 **상수 형태의 포인터** 이다. 그래서 배열의 이름을 가리켜 `포인터 상수`라 부르기도 한다.

<br>

> 1차원 배열이름의 포인터 형과 배열이름을 대상으로 하는 * 연산

**1차원 배열이름의 포인터 형은 배열의 이름이 가리키는 대상을 기준으로 결정하면 된다.**

```
1 #include <stdio.h>
2
3 int main(void)
4 {
5   int arr1[3]={1, 2, 3};
6   double arr2[3]={1.1, 2.2, 3.3};
7
8   printf("%d %g \n", *arr1, *arr2);
9   *arr1 += 100;
10  *arr2 += 120.5;
11  printf("%d %g \n", arr1[0], arr2[0]);
12  return 0;
13 }
```

```
1 1.1
101 121.6
```

<br>

> 포인터를 배열의 이름처럼 사용할 수도 있다.

사실 배열의 이름과 포인터 변수는 변수냐 상수냐의 특성적 차이가 있을 뿐, 둘 다 포인터이기 때문에 포인터 변수로 할 수 있는 연산은 배열의 이름으로도 할 수 있고, 배열의 이름으로 할 수 있는 연산은 포인터 변수로도 할 수 있다.

<br>

### 포인터 연산

> 포인터를 대상으로 하는 증가 및 감소연산

```c
1 #include <stdio.h>
2
3 int main(void)
4 {
5   int * ptr1=0x0010;
6   double * ptr2=0x0010;
7
8   printf("%p %p \n", ptr1+1, ptr1+2);  // 4가 증가하고 8이 증가
9   printf("%p %p \n", ptr2+1, ptr2+2);  // 8이 증가하고 16이 증가
10   // 16진수이기 때문에 26이 아니라 20이다. (9, a, b, c, d, e, f, 0)
11
12   printf("%p %p \n", ptr1, ptr2);
13   ptr1++;  // 4가 증가
14   ptr2++;  // 8이 증가
15
16   printf("%p %p \n", ptr1, ptr2);
17   return 0;
18 }
```

```
0x14 0x18
0x18 0x20
0x10 0x10
0x14 0x18
```

`포인터를 대상으로 하는 증가·감소 연산`의 결과는 다음과 같다.

- int형 포인터를 대상으로 n 증가 : n X sizeof(int) 의 크기만큼 증가·감소

- double형 포인터를 대상으로 n 증가 : n X sizeof(double) 의 크기만큼 증가·감소

**TYPE형 포인터를 대상으로 n의 크기만큼 값을 증가 및 감소 시, `n X sizeof(TYPE)`의 크기만큼 주소 값이 증가 및 감소한다.**

<br>

```c
1 #include <stdio.h>
2
3 int main(void)
4 {
5   int arr[3]={11, 22, 33};
6   int * ptr = arr;  // int * ptr=&arr[0] 과 같은 문장
7   printf("%d %d %d \n", *ptr, *(ptr+1), *(ptr+2));
8
9   printf("%d ", *ptr); ptr++;  // printf 함수 호출 후, ptr++ 실행
10   printf("%d ", *ptr); ptr++;
11   printf("%d ", *ptr); ptr--;  // printf 함수 호출 후, ptr-- 실행
12   printf("%d ", *ptr); ptr--;
13   printf("%d ", *ptr); printf("\n");
14   return 0;
15 }
```

```
11 22 33
11 22 33 22 11
```

포인터 변수 ptr은 int형 포인터이므로 값을 1 증가시키는 연산을 할 때마다 실제로는 4가 증가한다.

```c
*(++ptr)=20;  // ptr 저장된 값 자체를 변경

*(ptr+1)=20;  // ptr 저장된 값은 변경되지 않음
```

<br>

> 중요한 결론! **arr[i] == *(arr+i)**

앞선 코드에서 &#42;ptr, &#42;(ptr+1), &#42;(ptr+2)의 출력결과는 arr[0], arr[1], arr[2]의 출력결과와 동일함을 확인하였다. 그런데 배열의 이름과 포인터 변수는 상수냐 변수냐의 차이만 있을 뿐, 사실상 동일하다.

따라서 ptr에 저장된 값이 arr의 주소 값이기 때문에 다음 네 문장은 동일하다.

```c
printf("%d %d %D \n", *(ptr+0), *(ptr+1), *(ptr+2));  // *(ptr+0)는 *ptr과 같다.
printf("%d %d %d \n", ptr[0], ptr[1], ptr[2]);
printf("%d %d %d \n", *(arr+0), *(arr+1), *(arr+2));  // *(arr+0)는 *arr과 같다.
printf("%d %d %d \n", arr[0], arr[1], arr[2]);
```

따라서 우리는 다음의 식을 도출할 수 있다.

```c
// arr은 배열의 이름이어도 성립하고 포인터 변수여도 성립한다.

arr[i] == *(arr+1)  // arr[i]는 *(arr+i)와 같다.
```
<br>

| 배열에 저장된 값의 순서 역순으로 바꾸기

```c
1 #include <stdio.h>
2
3 int main(void)
4 {
5   int arr[6]={1, 2, 3, 4, 5, 6};
6   int * front=arr;
7   int * back=&arr[5];
8   int temp = 0;
9   int i;
10
11   for(i=0; i<3; i++)
12   {
13     temp=*(front+i);
14     *(front+i)=*(back-i);
15     *(back-i)=temp;
16   }
17
18   for(i=0;i<6;i++)
19     printf("%d \n", arr[i]);
20   return 0;
21 }
```

| 같은 temp 변수 이용 예제

- `temp 변수`를 눈여겨보자

```c
1 #include <stdio.h>
2
3 int main(void)
4 {
5   int num1=10, num2=20;
6   int* ptr1=&num1;
7   int* ptr2=&num2;
8   int* temp;  // int temp;   8, 13~15열을 모두 주석으로 변경해도 같은 결과가 나온다
9
10   (*ptr1)+=10;
11   (*ptr2)-=10;
12
13   temp=ptr1;  // temp=*ptr1;
14   ptr1=ptr2;  // *ptr1=*ptr2;
15   ptr2=temp;  // *ptr3=temp;
16
17   printf("%d %d \n", *ptr1, *ptr2);
18
19   return 0;
20 }

```



<br>

### 상수 형태의 문자열을 가리키는 포인터

> 두 가지 형태의 문자열 표현

**널 문자** 가 삽입되는 문자열의 선언방식에는 두 가지가 있다.

- 배열을 이용하는 방식

- char형 포인터 변수를 이용하는 방식

<br>

<p align='center'>
<img src='https://user-images.githubusercontent.com/39554623/54012977-0cbe5200-41bb-11e9-8979-4f1ba22e2699.png'>
</p>

<br>

str1은 그 자체로 문자열 전체를 저장하는 배열이고, str2는 메모리상에 자동으로 저장된 문자열 "Your String"의 첫 번째 문자를 단순히 가리키고만 있는 포인터 변수이다.

그러나 '배열이름' str1이 의미하는 것도 실제로는 문자 M의 주소 값이기 때문에 str1도 str2도 문자열의 시작 주소 값을 담고 있다는 측면에서는 동일하다. 다만 다음의 차이가 있을 뿐이다.

**배열이름 str1은 계속해서 문자 M이 저장된 위치를 가리키는 상태이어야 하지만 포인터 변수 str2는 다른 위치를 가리킬 수 있다.**

str2는 `변수형태의 포인터`이기 때문에 다음과 같은 문장을 구성할 수 있다.

```c
int main(void)
{
  char * str = "Your team";
  str = "Our team";  // str이 가리키는 대상을 문자열 "Our team"으로 변경
  . . . .
}
```

하지만 배열이름인 str1은 `상수형태의 포인터`이기 때문에 위와 같이 가리키는 대상을 변경할 수 없다. 그리고 또 한가지 중요한 차이점이 있다. 다음과 같이 선언이 되면 애초에 문자열은 배열에 저장된다. 그리고 배열을 대상으로는 값의 변경이 가능하기 때문에 다음과 같이 선언되는 문자열을 가리켜 **변수 형태의 문자열** 이라 한다.

```c
  char str1[] = "My String";
```

반면, 다음과 같이 선언되는 문자열은 **상수 형태의 문자열** 이라 한다.

```c
  char * str2 = "Your String";
```

<br>

### 포인터 변수로 이뤄진 배열: 포인터 배열

> 포인터 배열의 이해

포인터 변수로 이뤄진, 그래서 주소 값의 저장이 가능한 배열을 가리켜 `포인터 배열`이라 한다. 그리고 이러한 배열의 선언방식은 다음과 같다.

```c
int * arr1[20];  // 길이가 20인 int형 포인터 배열 arr1
double * arr2[30];  // 길이가 30인 double형 포인터 배열 arr2
```

<br>

| 포인터 배열의 선언과 활용의 예

```c
1 #include <stdio.h>
2
3 int main(void)
4 {
5   int num1=10, num2=20, num3=30;
6   int* arr[3]={&num1, &num2, &num3};
7
8   printf("%d \n", *arr[0]);
9   printf("%d \n", *arr[1]);
10  printf("%d \n", *arr[2]);
11  return 0;
12 }
```

<br>

> 문자열을 저장하는 포인터 배열

'문자열 배열'은 문자열의 주소 값을 저장할 수 있는 배열로서 사실상 char형 포인터 배열이다. 즉, 여기서 말하는 문자열 배열은 다음과 같다.

```c
  char * strArr[3];  // 길이가 3인 char형 포인터
```

<br>

```c
1 #include <stdio.h>
2
3 int main(void)
4 {
5   char * strArr[3]={"Simple", "String", "Ar    ray"};
6   printf("%s \n", strArr[0]);
7   printf("%s \n", strArr[1]);
8   printf("%s \n", strArr[2]);
9   return 0;
10 }
```

위 예제의 5행에는 다음과 같은 형태로 '문자열 배열'이 선언되어 있다.

```c
  char * strArr[3]={"Simple", "String", "Ar    ray"};
```

**큰따옴표로 묶여서 표현되는 문자열은 그 형태에 상관없이 메모리 공간에 저장된 후 그 주소 값이 반환된다.**

즉 위 문장이 실행되면 초기화 리스트에 선언된 문자열들은 메모리 공간에 저장되고, 그 위치에 저장된 문자열의 주소 값이 반환된다. 따라서 문자열이 저장된 이후에는 다음의 형태가 된다.

```c
  char * strArr[3]={0x1004, 0x1048, 0x2012};  // 반환된 주소 값은 임의로 결정됨
```

그런데 반환된 주소 값은 문자열의 첫 번째 문자의 주소 값이니, 이렇듯 char형 포인터 배열에 저장이 가능한 것이다.
