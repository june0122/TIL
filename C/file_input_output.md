# Chapter24. 파일 입출력

## 파일과 스트림(Stream), 그리고 기본적인 파일의 입출력

### 파일에 저장된 데이터를 읽고 싶을 때

<br>

<p align='center'>
<img src='https://user-images.githubusercontent.com/39554623/54546550-47a85d00-49e7-11e9-9bf9-2f7e1e23a883.PNG'>
</p>

<br>

- 프로그램상에서 파일에 저장되어 있는 파일을 참조하기 위해, 제일 먼저 할 일은?

    - 구현한 프로그램과 참조할 데이터가 저장되어 있는 파일 사이에 **데이터가 이동할 수 있는 다리**를 놓는 일이다.

    - 데이터 이동 경로가 되는 다리를 가리켜 **스트림(Stream)** 이라 한다.

- 스트림은 어디까지나 운영체제에 의해서 형성되는 소프트웨어적인 상태를 의미하는 것이다.

- 파일은 운영체제에 의해서 그 구조가 결정되고 관리되는 대상이기 때문에, 파일 뿐만 아니라 *스트림의 형성도 운영체제의 몫* 임을 기억하자.

<br>

### fopen 함수호출을 통한 파일과의 스트림 형성과 FILE 구조체

- 다음은 스트림을 형성할 대 호출하는 함수이다.
  
- 이 함수의 호출을 통해 프로그램상에서 파일과의 스트림을 형성할 수 있다.

```c
#include <stdio.h>
FILE * fopen(const char * filename, const char * mode)

    // 성공 시 해당 파일의 FILE 구조체 변수의 주소 값, 실패 시 NULL 포인터 반환
```

- 첫 번째 인자 : `스트림을 형성할 파일 이름`
    
- 두 번째 인자 : `형성할 스트림의 종류에 대한 정보를 문자열의 형태로 전달`

<br>

<p align='center'>
<img src='https://user-images.githubusercontent.com/39554623/54547734-aec71100-49e9-11e9-850b-485d60e8120c.jpg'>
</p>

> 프로그램상에서 fopen 함수를 호출했을 때 일어나는 일들

- fopen 함수가 호출되면 FILE 구조체 변수가 생성된다.
  
- 생성된 FILE 구조체 변수에는 파일에 대한 정보가 담긴다.

- FILE 구조체의 포인터는 사실상 파일을 가리키는 '지시자'의 역할을 한다.

<br>

### 입력 스트림과 출력 스트림의 생성

- 스트림은 *한 방향으로 흐르는 데이터의 흐름* 을 의미한다.

- 때문에 스트림은 `입력 스트림` 과 `출력 스트림` 으로 구분된다.

<br>

> fopen 함수를 호출할 때 전달되어야 하는 두 가지 인자

- 첫 번째 전달인자 : 스트림을 형성할 파일의 이름

- 두 번째 전달인자 : 형성하고자 하는 스트림의 종류

<br>

> 출력 스트림의 형성을 요청하는 fopen 함수의 호출문

```c
FILE * fp = fopen("data.txt", "wt");    // 출력 스트림의 형성

// 파일 data.txt와 스트림을 형성하되 wt 모드로 스트림을 형성해라
```

<br>

> 입력 스트림의 형성

```c
FILE * fp = fopen("data.txt", "rt");    // 입력 스트림의 형성

// 파일 data.txt와 스트림을 형성하되 rt 모드로 스트림을 형성해라 
```

- 참고로 fopen 함수 호출을 통해서 파일과의 스트림이 형성되었을 때, *파일이 개방(오픈)되었다* 라고 일반적으로 표현한다.

<br>

### 파일에 데이터를 써보자

> fputc('A', fp);

```c
  1 #include <stdio.h>
  2
  3 int main(void) {
  4   FILE * fp = fopen("data.txt", "wt");
  5   if(fp == NULL) {
  6     puts("파일 오픈 실패!");
  7     return -1;  // 비정상적 종료를 의미하기 위해서 -1을 반환
  8
  9
 10     fputc('A', fp);
 11     fputc('B', fp);
 12     fputc('C', fp);
 13     fclose(fp);
 14     return 0;
 15   }
 16 }
```

<br>

<p align='center'>
<img src='https://user-images.githubusercontent.com/39554623/54549008-74ab3e80-49ec-11e9-805d-fc4ea86c774e.PNG'>
</p>

<br>

### 스트림의 소멸을 요청하는 fclose 함수

- fopen 함수가 스트림을 형성하는 함수라면, fclose 함수는 스트림을 해제하는 함수이다.

- 다시 말해, fopen 함수가 파일을 개방하는 함수라면, fclose 함수는 파일을 닫는 함수이다.

```c
#include <stdio.h>
int fclose(FILE * stream);

    // 성공 시 0, 실패 시 EOF를 반환
```

> **fclose 함수를 통해 개방된 파일을 닫아줘야 하는 이유**

- 운영체제가 할당한 자원의 반횐

- 버퍼링 되었던 데이터의 출력

<br>

<p align='center'>
<img src='https://user-images.githubusercontent.com/39554623/54549407-585bd180-49ed-11e9-96cd-e1a6ea813f35.PNG'>
</p>

<br>

- fclose 함수의 호출을 통해서 파일을 닫아주면 출력 버퍼에 저장되어 있던 데이터가 파일로 이동하면서 출력버퍼는 비워지게 된다. 물론 그 이후엔 컴퓨터의 전원이 꺼져도 파일에 저장된 데이터는 소멸되지 않는다. 때문에 사용이 끝난 파일은 곧바로 fclose 함수를 호출해주는 것이 좋다.

<br>

### Chapter 21에서 호출한 적 있는 fflush 함수

- **스트림을 종료하지 않고 버퍼만 비우고 싶을 때에는 `fflush 함수`를 호출** 하면 된다.

```c
#include <stdio.h>
int fflush(FILE * stream);

    // 함수호출 성공 시 0, 실패 시 EOF 반환
```

> 입출력 버퍼를 비운다는 것

- 출력버퍼를 비운다는 것은 출력버퍼에 저장된 데이터를 목적지로 전송한다느 의미

- 입력버퍼를 비운다는 것은 입력버퍼에 저장된 데이터를 소멸시킨다는 의미

- fflush 함수는 출력버퍼를 비우는 함수이다.

- fflush 함수는 입력버퍼를 대상으로 호출할 수 없다.


```c
int main(void) {
    FILE * fp = fopen("data.txt", "wt");  // 출력 스트림 형성
    . . . .
    fflush(fp);  // 출력 버퍼를 비우라는 요청
    . . . .
}
```

- 이렇듯 `fflush 함수`는 **출력버퍼를 위한 함수**이다.

    - 파일 스트림의 입력버퍼를 비우는 함수는 필요가 없다.

<br>

### 파일로부터 데이터를 읽어보자

> 파일을 열어 안에 저장된 문자를 읽어들이는 예제

- **int ch = fgetc(fp);**

```c
  1 #include <stdio.h>
  2
  3 int main(void) {
  4   int ch, i;
  5   FILE * fp = fopen("data.txt", "rt");
  6   if(fp == NULL) {
  7     puts("파일오픈 실패!");
  8     return -1;
  9   }
 10
 11   for(i = 0; i < 3; i++)
 12   {
 13     ch = fgetc(fp);
 14     printf("%c \n", ch);
 15   }
 16   fclose(fp);
 17   return 0;
 18 }
```

```
A
B
C
```

<br>

## 파일의 개방 모드(Mode)

### 스트림을 구분하는 기준1 : 읽기 위한 스트림? 쓰기 위한 스트림?

- 데이터의 이동방향을 기준으로 다음과 같이 4가지로 구분할 수 있다.
  
    - 데이터 READ 스트림 : 읽기만 가능

    - 데이터 WRITE 스트림 : 쓰기만 가능

    - 데이터 APPEND 스트림 : 쓰되 덧붙여 쓰기 가능

    - 데이터 READ/WRITE 스트림 : 읽기, 쓰기 모두 가능

- 그러나 C언어는 이를 바탕으로 총 6가지로 스트림을 세분화한다.
  
<br>

|모드(mode)|스트림의 성격|파일이 없으면?|
|:---:|---|:---:|
|r|읽기 가능|에러|
|w|쓰기 가능|생성|
|a|파일의 끝에 덧붙여 쓰기 가능|생성|
|r+|읽기/쓰기 가능|에러|
|w+|읽기/쓰기 가능|생성|
|a+|읽기/덧붙여 쓰기 가능|생성|
<p align='center'>
<img src=''>
</p>

- 위 표를 참조하여 필요로 하는 스트림의 특성과 일치하는 `파일의 개방 모드(mode)`를 선택하면 된다.
  
- 그리고 모드의 이름이 fopen 함수의 두 번째 인자가 된다.

<br>

> 수월한 모드 선택을 위한 팁

- 모드의 +는 읽기, 쓰기가 모두 가능한 스트림의 형성을 의미한다.

- 모드의 a는 쓰기가 가능한 스트림을 형성하는데, 여기서 말하는 쓰기는 덧붙이기이다.

<br>

> 왠만하면 `r, w, a` 중에서 선택하자

- 파일의 개방 모드 중 `r+ , w+, a+`는 읽기와 동시에 쓰기가 가능하므로 더 좋은 모드라 생각할 수 있다. 하지만 이러한 모드를 기반으로 작업하는 경우에는 읽기에서 쓰기, 그리고 쓰기에서 읽기로 작업을 변경할 때마다 메모리 버퍼를 비워줘야 하는 등의 불편함과 더불어 잘못된 사용의 위험성도 따른다.

<br>

### 텍스트 파일과 바이너리 파일