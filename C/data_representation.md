# Chapter04. 데이터 표현 방식의 이해

> 컴퓨터는 2진수를 기반으로 데이터를 표현하고 연산도 진행한다.

> 2, 10, 16 진수의 이해

- 진법에 대한 기본적인 원리 이해를 위해 10진수를 여러 진법으로 바꾸는 연습

> 데이터의 표현단위인 비트(Bit)와 바이트(Byte)

<p align="center">
<img src="https://user-images.githubusercontent.com/39554623/53630233-f3fdeb80-3c52-11e9-9c2b-4c1da5be46ff.png">
<p>

- **비트**

  - 컴퓨터가 표현하는 **데이터의 최소단위** 로서 **2진수 값 하나를 저장할 수 있는 메모리의 크기** 를 뜻하는 단위이다.

  - 또한 비트를 여덟 개 묶으면 **바이트** 라는 단위가 구성된다.

  - n개의 비트를 가지고 표현할 수 있는 데이터의 수는 `2^n` 개이다.

> 8진수와 16진수를 이용한 데이터 표현

C언어는 10진수 이외에 8진수와 16진수의 데이터 표현도 허용을 한다. 따라서 변수 선언 후에 10진수가 아닌, 16진수나 8진수의 표현방식으로 변수에 값을 채울 수도 있다.

```
int num1 = 10;    // 특별한 선언이 없으면 10진수의 표현
int num2 = 0xA;   // 0x로 시작하면 16진수로 인식
int num3 = 012;   // 0으로 시작하면 8진수로 인식
```

### 정수와 실수의 표현방식

> 정수의 표현방식

<p align="center">
<img src="https://user-images.githubusercontent.com/39554623/53706575-5a128a80-3e6e-11e9-8232-157cfe0b1c59.png">
<p>

정수를 표현하는데 있어서 가장 왼쪽에 존재하는 비트는 부호를 표현하는데 사용한다. 양수라면 0, 음수라면 1을 저장하여 부호를 표시.

이 비트를 가르켜 **MSB(Most Significant Bit, 가장 중요한 비트)** 라고 한다.

> 음의 정수 표현하기

- **`2의 보수법`** : 표현하고자 하는 음의 정수의 절대값에 **1의 보수** 를 취한뒤 **1을 더한다.**

<p align="center">
<img src="https://user-images.githubusercontent.com/39554623/53706574-5a128a80-3e6e-11e9-9cb5-d2699751a187.png">
<p>

> 실수의 표현방식

<p align="center">
<img src="https://user-images.githubusercontent.com/39554623/53706829-9b576a00-3e6f-11e9-9d51-3dd663f134de.png">
<p>

- **컴퓨터가 실수를 표현하는 방식에는 오차가 존재한다.**

- 컴퓨터가 소수점 이하의 수를 표현하는데 있어서 부동 소수점 방식을 사용하기 때문에 **부동 소수점 오차** 가 발생한다.

```
 1 #include <stdio.h>
 2
 3 int main(void)
 4 {
 5   int i;
 6   float num= 0.0;
 7
 8   for(i=0; i<100;i++)
 9     num+=0.1;
10
11     printf("0.1을 100번 더한 결과 : %f \n",     num);
12     return 0;
13 }
```
<p align="center">
<img src="https://user-images.githubusercontent.com/39554623/53708393-90540800-3e76-11e9-88b4-e0578b67f600.PNG">
<p>

- 0.1을 100번 더했으니 10.0이 출력되어야 하는데 다른 값이 출력되었다.

- 컴퓨터는 실수를 100% 정확히 표현하지 못한다. 다만 근사치를 표현할 뿐이다.

### 비트 연산자

> ※ 아래의 표에서 `<<`,`>>` 연산자는 '비트 이동(shift) 연산자'라 해서 비트 연산자와는 성향이 조금 다르지만 흔히 비트 연산자의 범주에 포함시켜서 이야기하기 때문에 함께 정리하였다.

|연산자|<center>연산자의 기능</center>|결합방향|
|:---:|:---|:---:|
|&|비트단위로 AND 연산을 한다.<br>예시) num1 & num2;|→|
|&#124;|비트단위로 OR 연산을 한다.<br>예시) num1 &#124; num2;|→|
|^   |비트단위로 XOR 연산을 한다.<br>예시) num1 ^ num2;   |→   |
|~   |단항 연산자로서 피연산자의 모든 비트를 반전시킨다.<br>예시) ~num;   |←   |
|<<   |피연산자의 비트 열을 완쪽으로 이동시킨다.<br>예시) num<<2;   |→   |
|>>   |피연산자의 비트 열을 오른쪽으로 이동시킨다.<br>예시) num>>2;   |→   |

> << 연산자 :  비트의 왼쪽 이동

```
  1 /*
  2   BitLeftShift
  3   << 연산자 :  비트의 왼쪽 이동
  4 */
  5
  6 #include <stdio.h>
  7
  8 int main(void)
  9 {
 10   int num = 15;    // 00000000 00000000 0000000    0 00001111
 11
 12   int result1 = num<<1;    // num의 비트 열을 >    왼쪽으로 1칸씩 이동
 13   int result2 = num<<2;    // num의 비트 열을 >    왼쪽으로 2칸씩 이동
 14   int result3 = num<<3;    // num의 비트 열을 >    왼쪽으로 3칸씩 이동
 15
 16   printf("1칸 이동 결과: %d \n", result1);
 17   printf("2칸 이동 결과: %d \n", result2);
 18   printf("3칸 이동 결과: %d \n", result3);
 19   return 0;
 20 }
```

![비트왼쪽이동](https://user-images.githubusercontent.com/39554623/53711496-c77de580-3e85-11e9-9ffe-e0807a0eaee7.PNG)

- 비트의 열을 **왼쪽** 으로 1칸씩 이동시킬 때마다 정수의 값은 **2배가 된다.**

- 비트의 열을 **오른쪽** 으로 1칸씩 이동시킬 때마다 정수의 값은 **2로 나누어진다.**
  - 그러나 >>연산을 음수에 적용시키면 비트 왼쪽에 생긴 공백을 음의 값을 유지하기 위해 1을 채우는 CPU도 있고, 이에 상관하지 않고 0을 채우는 CPU도 존재한다.
