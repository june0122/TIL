# Chapter05. 상수와 기본 자료형

### 기본 자료형의 이해

> 자료형이란?

자료형은 데이터를 표현하는 기준이다. 때문에 변수도 상수도 자료형에 근거한다.

아래의 표에서 자료형 char은 1바이트(8비트)이므로 나타낼 수 있는 데이터의 종류가 2^8=256개이다. 따라서 -128부터 +127까지 표현하도 정의된 자료형이다.

<p align="center">
<img src="https://user-images.githubusercontent.com/39554623/53712940-5261de80-3e8c-11e9-90d7-7ae795eedfdf.jpg">
<p>

- ※ short와 int는 최소 2바이트이되, int는 short보다 크기가 같거나 더 커야 한다.

- 자료형 별 크기를 정확히 제한하고 있지 않다. 따라서 자료형 별 크기는 컴파일러마다 차이를 보인다.

> 왜 많은 수의 자료형이 제공되는 것일까?

- 첫째, 데이터의 표현방식이 다르므로, 최소 둘 이상의 자료형이 필요하다.

- 둘째, 메모리 공간의 적절한 사용을 위해서 다양한 크기의 자료형이 필요하다.

> **연산자 sizeof** 를 이용하면 자료형의 크기를 확인 가능

메모리 공간에서 소모하는 메모리의 크기를 바이트 단위로 계산해서 반환하는 sizeof 연산자가 존재한다.

이 연산자의 피연산자로는 변수와 상수뿐만 아니라, 자료형의 이름도 올 수 있기 대문에 이 연산자를 이용해서 사용하는 컴파일러의 자료형 별 바이트 크기도 확인 가능하다.

  - 문장 이해의 도움을 위해 sizeof 연산자의 피연산자를 소괄호로 감싸다보니 sizeof 연산자를 함수로 오해하는 경우가 많으니 주의하도록 하자.

> 정수를 표현 및 처리하기 위한 일반적인 자료형의 선택

일반적으로 **CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 int로 정의한다.** 따라서 int형 연산의 속도가 다른 자료형의 연산속도에 비해서 동일하거나 더 빠르다.

특히 연산의 횟수가 빈번한 경우에는 저장되는 값의 크기가 작더라도 int형 변수를 선언하는 것이 좋다.

```
"데이터의 양이 많아서 연산속도보다 데이터의 크기를 줄이는 것이 더 중요한 데이터들"

MP3와 같은 음성 데이터나 영상 데이터와 같이 크기에 민감한 데이터들에는 char형, 그리고 short형 변수가 유용하게 사용된다.
```

> 실수를 표현 및 처리하기 위한 일반적인 자료형의 선택

**실수 자료형의 선택에 있어서 가장 중요한 요소는 '정밀도'이다.**

  - 정밀도 : 오차가 발생하지 않는 소수점 이하의 자릿수

|실수 자료형|소수점 이하 정밀도|바이트 수|
|:---:|:---:|:---:|
|float   |6자리   |4   |
|double   |15자리   |8   |
|long double   |18자리   |12   |

과거에는 float이 실수 자료형으로 보편적으로 사용되었으나 현재는 double이 보편적이 되었다. double이 보편적 선택이 될 수 있는 이유는 float보다 정밀도가 높으면서도(float은 정밀도가 너무 낮다) long double보다는 부담이 덜 되기 때문이다.

```c
1 #include <stdio.h>
2
3 int main(void)
4 {
5   double rad;
6   double area;
7   printf("원의 반지름 입력: ");
8   scanf("%lf", &rad);
9
10   area = rad*rad*3.1415;
11   printf("원의 넓이: %f \n", area);
12   return 0;
13 }
```

- double형 데이터를 출력할 때에는 서식문자 `%f`를 사용하지만, double형 데이터를 입력 받을 때에는 서식문자 `%lf`를 사용한다.

> unsigned를 붙여서 0과 양의 정수만 표현하게 할 수 있다.

- **정수 자료형의 이름 앞에만** `unsigned`를 붙일 수 있다.

  - 정수 자료형의 이름 앞에는 `signed` 선언을 추가할 수 있는데, 결국 `int`와 `signed int`는 같은 선언이므로 signed라는 키워드를 생략한다.

  - 그러나 `char`형은 예외일 수도 있다. char를 `unsigned char`로 처리하는 컴파일러도 존재하기 때문에 char형 변수를 선언해서 음의 정수를 저장하는 경우에는 `signed` 선언을 추가하기도 한다.


- unsigned가 붙으면, **MSB도 데이터의 크기를 표현하는데 사용이 된다.**

- 따라서 표현할 수 있는 값이 0 이상의 범위로 두 배가 된다.

<p align="center">
<img src="https://user-images.githubusercontent.com/39554623/53716139-42033100-3e97-11e9-994a-2b6c77de7edf.PNG">
<p>

### 문자의 표현방식과 문자를 위한 자료형에

> 문자의 표현을 위한 약속: 아스키(ASCII) 코드

숫자를 이용해 문자를 표현하려면 숫자를 문자에 연결(mapping)시키는 것이 유일한 방법.

C 언어는 미국 표준 협회(ANSI)에 의해 제정된 **아스키(ASCII) 코드** 라는 표준을 선택해서 문자를 표현.

> 서식문자 `%c` : 문자의 형태로 데이터를 출력(또는 입력)하라.

- 정수는 출력의 방법에 따라서 문자의 형태로도, 숫자의 형태로도 출력이 가능하다.

```C
int main(void)
{
  char ch1 = 'A', ch2 = 65;
  int ch3 = 'Z', ch4 = 90;

  printf("%c %d \n", ch1, ch1);
  printf("%c %d \n", ch2, ch2);
  printf("%c %d \n", ch3, ch3);
  printf("%c %d \n", ch4, ch4);
  return 0;
}
```

```
출력결과
------------
A 65
A 65
Z 90
Z 90
```

### 상수에 대한 이해

> 이름을 지니지 않는 리터럴(Literal) 상수

```c
int main(void)
{
  int num = 30 + 40;  // 30과 40은 상수이다.
  . . .
}
```

변수와 달리 이름이 없는 상수를 가리켜 **리터럴 상수** 또는 그냥 **리터럴** 이라 한다.

> 리터럴 상수의 자료형

- int형으로 표현 가능한 정수형 상수는 int형으로 메모리 공간에 저장하기로 약속되어 있다.

- double형으로 표현 가능한 실수형 상수는 double형으로 저장하기로 약속되어 있다.

- 대입 연산자의 왼편에 있는 변수의 자료형에 따라서 상수의 자료형이 결정되는 것은 아니다.

> 접미사를 이용한 다양한 상수의 표현

```c
float num1 = 5.789;
float num2 = 3.24 + 5.12;

// 컴파일은 가능하나 경고 메시지 발생
// "초기화할 때, double형 데이터를 float형 변수에 저장하였으니, 데이터가 잘려나갈 수도 있습니다."
```

```c
float num1 = 5.789f;  // 경고 메시지 발생 안 함
float num2 = 3.24F + 5.12F;  // 소문자 f 대신 대문자 F를 써도 된다.
```

| **정수형 상수**의 표현을 위한 접미사

|접미사|자료형|사용의 예|
|:---:|:---:|:---:|
|U   |unsigned int   |unsigned int n = 1025U   |
|L   |long   |long n = 2467L   |
|UL   |unsigned long   |unsigned long n = 3456UL   |
|LL   |long long   |long long n = 5768LL   |
|ULL   |unsigned long long   |unsigned long long n = 8979ULL   |

| **실수형 상수**의 표현을 위한 접미사

|접미사|자료형|사용의 예|
|:---:|:---:|:---:|
|  F |float   |float f = 3.15F   |
|L   |long double   |long double f = 5.789L   |

`위의 접미사들은 대소문자를 구분하지 않으므로 상황에 맞게 선택하면 된다.`

> 이름을 지니는 **심볼릭(Symbolic) 상수** : **const 상수**

심볼릭 상수는 변수와 마찬가지로 이름을 지니는 상수로 표현하는 방법에는 두 가지가 있다.

- `const 키워드`를 사용하는 방법

- `매크로`를 이용하는 방법

매크로는 Ch.26에서 배우므로 const 키워드를 사용하는 방법을 먼저 배운다.

- 변수 선언 시 const 선언만 추가해주면 끝!

- 단 상수이므로 선언과 동시에 초기화를 해야 한다.

```c
int main(void)
{
  const int MAX = 100;  // MAX는 상수, 따라서 값의 변경 불가
  const double PI = 3.1415;  // PI는 상수, 따라서 값의 변경 불가
  . . . .
}
```

심볼릭 상수도 상수의 일종이므로, 일단 초기화되면 그 값을 변경시킬 수 없다. 뿐만 아니라, 아래와 같이 선언과 초기화를 분리시킬 수도 없다.

```c
int main(void)
{
  const int MAX;  // 쓰레기 값으로 초기화 되어버림
  MAX = 100;  // 값의 변경 불가, 따라서 컴파일 에러 발생
  . . . .
}
```

**상수의 이름은 모두 대문자로 표시하고, 둘 이상의 단어로 연결할 때에는 MY_AGE와 같이 언더바를 이용해서 두 단어를 구분하는 것이 관례이다.**

### 자료형의 변환

> **자료형 변환** : 데이터의 표현방식을 바꾸는 것

- 자동 형 변환(묵시적 형 변환)

- 강제 형 변환(명시적 형 변환)

> 대입연산의 전달과정에서 발생하는 자동 형 변환

**|** *정수를 실수로 형 변환하는 경우*

```c
double num1 = 245;  // int형 정수 245를 double형으로 자동 형 변환
```

int형 정수인 245가 double형 실수 245.0으로 형 변환되어서 num1에 저장.

**|** *실수를 정수로 형 변환하는 경우*

```c
int num2 = 3.1415;  // double형 실수 3.1415를 int형으로 자동 형 변환
```

double형 상수 3.1415가 int형으로 변환되어서 변수 num2에 저장. 하지만 int형으로는 소수점 이하 값을 표현 못하므로, 형 변환의 과정에서 3.1415가 3으로 변환되어 그 결과값이 num2에 저장된다.

**실수형 데이터를 정수형 데이터로 변환하는 과정에서는 `소수부의 손실`이 발생한다.**

**|** *바이트 크기가 큰 정수를 바이트 크기가 작은 정수로 형 변환하는 경우*

```c
int num3 = 129;  // 00000000 00000000 00000000 10000001
char ch = num3;  // int형 변수 num3에 저장된 값이 char형으로 자동 형 변환
```

129가 저장된 num3의 비트 열은 다음과 같이 4 바이트이다.

`00000000 00000000 00000000 10000001`

그런데 이 데이터를 변수 ch에 저장하기 위해서는 1바이트 크기로 줄여야 한다. 따라서 이 경우에는 `상위 바이트 손실`이 발생하며, 그 결과는 다음과 같다.

`10000001`  → 이는 정수로 -127

이처럼 상위 바이트의 손실로 인해 부호가 바뀌는 경우가 있으니 주의해야 한다.

- **데이터의 표현범위가 넓은 자료형으로의 형 변환은 데이터 손실 발생 X**

- **데이터 표현범위가 좁은 자료형으로의 형 변환은 데이터 손실 발생 O**

> `정수의 승격(Integral Promotion)`에 의한 자동 형 변환

```c
int main(void)
{
  short num1=15, num2=25;
  short num3=num1+num2;  // num1과 num2가 int로 형 변환
  . . . .
}
```

일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 int로 정의한다. 따라서 int형 연산의 속도가 다른 자료형의 연산 속도에 비해서 동일하거나 더 빠르다. 따라서 int보다 작은 크기의 정수형 데이터는 int형 데이터로 형 변환이 되어서 연산이 진행된다.

이러한 형태의 형 변환을 가리켜 `정수의 승격`이라 한다.

> 피연산자의 자료형 불일치로 발생하는 자동 형 변환

```c
double num1 = 5.15 + 19;

// int형 정수를 double형 실수로 형 변환하여 5.15 + 19.0 = 24.15라는 결과가 나온다.
```

**피연산자의 자료형이 일치하지 않아서 발생하는 자동 형 변환은 데이터의 손실을 최소화하는 방향으로 진행된다.**

| 산술연산에서의 형 변환 규칙

<p align="center">
<img src="https://user-images.githubusercontent.com/39554623/53728254-a3d29380-3eb5-11e9-9635-94b927a813ad.png">
<p>

위 그림에서 보이는 화살표의 방향은 형 변환에서의 상대적 우선순위를 나타낸다. 순위의 기준은 바이트 크기가 아니라, **데이터 손실의 최소화** 에 있다. 그래서 **형 변환의 우선순위는 정수 자료형보다 실수 자료형이 무조건 앞서는 형태로 정의** 되어 있다.

> 명시적 형 변환 : 강제로 일으키는 형 변환

```c
1 #include <stdio.h>
2
3 int main(void)
4 {
5   int num1=3, num2=4;
6   double divResult;
7   divResult = num1 / num2;
8   printf("나눗셈 결과: %f \n", divResult);
9   return 0;
10 }
```

```
나눗셈 결과: 0.000000
```

위의 예제에서 나눗셈의 결과로 0.75가 출력될 것을 기대했을지도 모른다. 하지만 **연산결과의 자료형은 피연산자의 자료형과 일치** 하기 때문에, 나눗셈의 결과는 0이 되고(정수형 나눗셈 결과의 몫), 이 값이 double형으로 자동 형 변환되어 변수 divResult에 저장된다. 따라서 위와 같은 결과가 나온 것이다.

0.75를 출력하기 위해선 6번 째 행을 아래와 같이 수정한다.

```c
divResult = (double)num1 / num2;
```

이렇게 사용되는 소괄호를 가리켜 `형 변환 연산자(type casting operator)`라 한다.

위의 문장에서 제일 먼저 진행되는 연산은 형 변환 연산이고, 연산의 결과로 다음고 같은 형태가 된다.

`divResult = 3.0 /  num2;`

이어서 나눗셈을 진행할 차례인데, 산술연산의 형 변환 규칙에 의해 num2에 저장된 값도 double형으로 자동 형 변환된다.

`divResult = 3.0 / 4.0;`

마지막으로 나눗셈이 진행되고, 그 결과가 divResult에 저장된다. 따라서 저장되는 값은 0.75가 된다.
