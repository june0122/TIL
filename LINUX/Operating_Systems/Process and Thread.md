# 프로세스와 스레드의 차이

## 프로그램 <sup>Program</sup>

- 작업을 위해서 실행할 수 있는 파일 <sup>An executable file</sup>
- 프로그램 자체는 생명이 없다.
- 프로그램은 보조 기억장치(하드디스크, SSD)에 존재하며 실행되기를 기다리는 명령어(코드)와 정적인 데이터의 묶음이다.

## 프로세스 <sup>Process</sup>

> 실행 중인 프로그램  <sup>Computer program in execution</sup>

<p align = 'center'>
<img width = '500' src = 'https://user-images.githubusercontent.com/39554623/118906544-eda1da00-b958-11eb-9693-153dea309a2d.png'>
</p>


프로그램의 명령어와 정적 데이터가 메모리에 적재되면 생명이 있는 프로세스가 된다. (프로그램이 보조 기억장치로부터 메모리에 적재되어 CPU의 할당을 받게 되면 프로세스가 된다.)

- 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
- 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신 <sup>IPC, inter-process communication</sup>을 사용해야 한다.
  - Ex) 파이프, 파일, 소켓 등을 이용한 통신 방법 이용

### 프로세스의 구성

프로세스에 대한 정보는 **프로세스 제어 블록 <sup>PCB, Process Control Block</sup>** 이라고 부르는 자료구조에 저장된다.

운영체제는 프로세스를 관리하기 위해 **프로세스의 생성과 동시에 고유한 PCB를 생성** 한다. 프로세스는 CPU 를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU 를 반환해야 하는데, 이때 작업의 진행 상황을 모두 PCB 에 저장하게 된다. 그리고 다시 CPU 를 할당받게 되면 PCB 에 저장되어있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행한다.

> PCB에 저장되는 정보

- 프로세스 식별자 <sup>PID, Process ID</sup> : 프로세스 식별번호
- 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
- 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
- CPU 레지스터
- CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
- 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
- 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
- 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

> 프로세스의 메모리 구조

<p align = 'center'>
<img width = '300' src = 'https://user-images.githubusercontent.com/39554623/118899976-df4cc180-b94a-11eb-935c-48fc7c22e6df.png'>
</p>

① text(code) 영역

- 코드 자체를 구성하는 메모리 영역으로 Hex파일이나 BIN파일 메모리
- 프로그램 명령이 위치하는 곳으로 기계어로 제어되는 메모리 영역
  
② data 영역

- 전역변수(global), 정적변수(static), 배열(array), 구조체(structure) 등이 저장된다.
- 초기화 된 데이터는 data 영역에 저장되고, 초기화 되지 않은 데이터는 BSS (Block Stated Symbol) 영역에 저장된다.
- 프로그램이 실행 될 때 생성되고 프로그램이 종료 되면 시스템에 반환
- 함수 내부에 선언된 Static 변수는 프로그램이 실행 될 때 공간만 할당되고, 그 함수가 실행 될 때 초기화

> Data 영역과 BSS 영역을 구분 하는 이유?

초기화가 되지 않는 변수는 프로그램이 실행될때 영역만 잡아주면 되고 그 값을 프로그램에 저장하고 있을 필요는 없으나 초기화가 되는 변수는 그 값도 프로그램에 저장하고 있어야 하기때문에 두가지를 구분해서 영역을 잡는것이다. 이것이 bss영역을 구분하는 이유이다. 따라서 이러한 bss영역 변수들은 많아져도 프로그램의 실행코드 사이즈를 늘리지 않는다.

③ heap 영역

- 필요에 의해 동적으로 메모리를 할당 하고자 할 때 위치하는 메모리 영역으로 동적 데이터 영역이라고 부르며, 메모리 주소 값에 의해서만 참조되고 사용되는 영역이다.
- 이 영역에 데이터를 저장 하기 위해서 C는 malloc(), C++은 new() 함수를 사용한다.

④ stack 영역

- 프로그램이 자동으로 사용하는 임시 메모리 영역이다.
- 지역(local) 변수, 매개변수(parameter), 리턴 값 등 잠시 사용되었다가 사라지는 데이터를 저장하는 영역이다.
- 함수 호출 시 생성되고, 함수가 끝나면 시스템에 반환 된다.
- 스택 사이즈는 각 프로세스마다 할당 되지만 프로세스가 메모리에 로드 될 때 스택 사이즈가 고정되어 있어, 런타임 시에 스택 사이즈를 바꿀 수는 없다.
- 명령 실행시 자동 증가/감소 하기 때문에 보통 메모리의 마지막 번지를 지정 한다.

> 스택 영역과 힙 영역 사이에 빈 공간이 존재하는 이유?

스택영역과 힙영역 사이에 빈 공간은 **컴파일 타임에 지역변수를 얼마나 사용할지 미리 계산할 수 없기 때문에** 런타임에 지역변수 선언 순서에 따라 스택영역은 위쪽으로 주소 값을 매기고 동적 할당될때 힙영역은 아래쪽으로 주소값을 매깁니다.

## 쓰레드 <sup>Thread</sup>

> 프로세스 내의 실행 단위 <sup>the unit of execution within a process</sup>

<p align = 'center'>
<img width = '500' src = 'https://user-images.githubusercontent.com/39554623/118901583-9c8ce880-b94e-11eb-86d6-f94bd3d6074d.png'>
</p>

- 스레드는 프로세스 내에서 각각 **Stack만 따로 할당받고** Code, Data, Heap 영역은 공유한다.
- 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
- 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
- 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
- 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.
- concurrency와 parallelism<sup id = "a1">[1](#f1)</sup>

> 스택을 스레드마다 독립적으로 할당하는 이유

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

> PC Register 를 스레드마다 독립적으로 할당하는 이유

PC 값은 스레드가 명령어의 어디까지 수행하였는지를 나타나게 된다. 스레드는 CPU 를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC 레지스터를 독립적으로 할당한다.

## References

- [프로세스와 스레드의 차이](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)
- [프로세스가 뭐지?](https://bowbowbow.tistory.com/16)
- [운영체제 - Process](https://dev-ahn.tistory.com/15)
- [프로세스와 스레드 차이](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)
- [병행성(Concurrency)와 병렬성(Parallelism)의 차이에 대해](https://nesoy.github.io/articles/2018-09/OS-Concurrency-Parallelism)
- [프로세스는 뭐고 스레드는 뭔가요?](https://youtu.be/iks_Xb9DtTM)


---

## <b id = "f1"><sup> 1 </sup></b> concurrency와 parallelism [ ↩](#a1)

### 병행성 <sup>concurrency</sup>

> 동시에 실행되는 것처럼 보이는 것

- Logical Level에 속한다.
- Single Core
  - 물리적으로 병렬이 아닌 순차적으로 동작할 수 있따.
  - 실제로는 Scheduling을 통해 CPU의 자원을 나눠서 사용하여 동시에 실행되는 것처럼 보이게 한다.
- Multi Core
  - 물리적으로 병렬로 동작할 수 있다.
- Case
  - Mutex, Deadlock

### 병렬성 <sup>parallelism</sup>

> 실제로 동시에 작업이 처리가 되는 것

- Physical(Machine) Level에 속한다.
- 오직 Multi Core에서만 가능하다.
- Case
  - OpenMP, MPI, CUDA