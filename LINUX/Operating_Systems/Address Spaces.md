# Address Spaces

## Memory Management

- To execute programs, code and data should be placed in the **main memory**
  - Von Neumann <sup>폰 노이만</sup> architecture!

- Each process needs its own address space

- However, memory is an expensive system resource
  - Unit price: ￦40,000 / 8 GB RAM vs. ￦100,000 / 500 GB for SSD
  - Power consumption

- Should manage memory efficiently

- Lessons from the processor
  - We’ve discussed many concepts that abstract CPU/processors
  - Schedulers provide a **virtualized environment** to processes

- Why not for the memory?

- Yes, operating systems do those with memory;
  - Allocate memory to processes
  - Provide separate address spaces to processes
  - Allow processes to relocate (dynamic linking)
  - Provide a physically contiguous address space
  - Fragmentation management (compaction, movable)
  - Caching
  - Allow module hot-swapping
  - Allow overprovisioning and power management
  - Performance
  - And more …

## Address in Computers

- A location in the memory

- An address can be represented in different forms <sup>수많은 addressing 방법 존재</sup> 
  - **Physical address** vs **Logical address**
  - **Absolute address** vs **Relative address**

<br>
<p align = 'center'>
<img width = '450' src = 'https://user-images.githubusercontent.com/39554623/85936396-5a714780-b935-11ea-886d-c4f26624d671.png'>
</p>


- **Physical address (PA)**
  - Address seen by the memory unit

- **Virtual address (VA) or Logical address (LA)**
  - Generated by the CPU

- **Memory Management Unit (MMU) translates LA to PA**

<br>
<p align = 'center'>
<img width = '600' src = 'https://user-images.githubusercontent.com/39554623/85936450-fac76c00-b935-11ea-8765-77a6abb3f6be.png'>
</p>
<br>

- **Processors see logical addresses**
  - So does for processes
  
- MMU translates the LAs to PAs
  - Need a mechanism and a data structure to map LAs to PAs
    - Will be discussed later
  - Assume MMU can map a LA to any physical location

- Each process requires its own address space
 
- How can we place process address spaces (which is logical) on the physical memory address space??

## Fixed Partitions

> Physical address = base address + virtual address

- Break up physical memory into same-sized partitions
  - **Physical address = base address <sup>시작주소</sup> + virtual address**
  - Cannot access beyond its partition
  - The number of partitions = degree of multiprogramming

- How can realize this idea?
  - Put a base register in **MMU**
    - OS loads the base register when it switches processes
  - Check whether `virtual address >= partition size`
    - 위 조건을 만족하지 못하면 다른 프로세스의 address space를 침범할 수 있음

- address space를 partition으로 쪼갠 개수만큼이 해당하는 시스템의 multi-programming degree가 된다.

<br>

> 서로 다른 2개의 프로세스가 서로 같은 Logical address를 사용하고 있어도 운영체제의 memory management를 통해서 Physical address의 서로 다른 위치로 Mapping 된다.

<br>
<p align = 'center'>
<img width = '550' src = 'https://user-images.githubusercontent.com/39554623/85936544-e9329400-b936-11ea-9849-05a62aae4709.png'>
</p>
<br>

<br>
<p align = 'center'>
<img width = '400' src = 'https://user-images.githubusercontent.com/39554623/85936545-e9cb2a80-b936-11ea-91da-dc9e4190f0a9.png'>
&ensp;
<img width = '400' src = 'https://user-images.githubusercontent.com/39554623/85936546-ea63c100-b936-11ea-809a-22f35b65627f.png'>
</p>
<br>

- Advantage
  - Easy to implement
  - Easy to validate access
    - Compare logical address to the partition size
  - Fast context switch
    - Just save/restore the base register on context switch

- Problem
  - Partition size: One size does not fit all
    - Partition이 작으면 하나의 프로그램이 사용할 수 있는 최대의 메모리가 작아진다.
    - Partition이 크면 multi-programming degree가 낮아지고 Internal fragmentation 문제가 발생한다.
  - Internal fragmentation

### Internal fragmentation <sup>메모리 내부 단편화</sup>

> 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비 되는 상황

- Suppose a resource is divided into a fixed size chunks, and assigned to instances (e.g., processes)
- Each memory chunk is exclusively <sup>독점적으로</sup> assigned to an instance
- Even if a part of the resource is not being used by the owner instance, it cannot be utilized by other instances

<br>
<p align = 'center'>
<img width = '400' src = 'https://user-images.githubusercontent.com/39554623/85936958-627fb600-b93a-11ea-9860-ce46ed9b0aef.png'>
</p>
<br>

## Variable Partitions

- Improve the fixed partitioning
  - Allow variable partition sizes
  - Assume OS knows the memory size that processes need in advance
  - Allocate a contiguous chunk from holes

- Should check the access limit considering the allocated memory size

- 장점
  - No internal fragmentation

- 단점
  - Context switch를 할 때, Limit register 값의 변경도 관리해주어야 한다.
  - 어떤 프로세스의 메모리에서 Limit이 어디까지 가는지를 tracking 해줘야하고 관리를 해줘야한다.
  - **External fragmentation**

<br>
<p align = 'center'>
<img width = '600' src = 'https://user-images.githubusercontent.com/39554623/85937098-40d2fe80-b93b-11ea-81d5-e3c2eee36625.png'>
</p>
<br>

<br>
<p align = 'center'>
<img width = '600' src = 'https://user-images.githubusercontent.com/39554623/85937099-416b9500-b93b-11ea-9758-45f7a030e026.png'>
</p>
<br>

### External fragmentation <sup>메모리 외부 단편화</sup>

> 메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간중간 존재하게 된다. 이 때 중간중간에 생긴 사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황

- As OS load and unload processes, holes are left **scattered** throughout physical memory
- Become unable to allocate a **contiguous <sup>연속적인</sup> chunk** even though the sum of holes is greater than the required chunk

<br>
<p align = 'center'>
<img width = '600' src = 'https://user-images.githubusercontent.com/39554623/85937220-7af0d000-b93c-11ea-881e-b0fc1f5b3b90.png'>
</p>
<br>

- Solutions for external fragmentation
  - Contiguous: **Compaction <sup>꽉 채움</sup>**
  - Non-contiguous: **Paging** and segmentation

<br>
<p align = 'center'>
<img width = '600' src = 'https://user-images.githubusercontent.com/39554623/85937335-7aa50480-b93d-11ea-8c4e-96e2d68bb729.png'>
</p>
<br>

### Allocation strategies

> 프로세스가 메모리를 요청할 때, 프로세스가 사용할 공간을 어디에 할당할 것인가?

<br>
<p align = 'center'>
<img width = '600' src = 'https://user-images.githubusercontent.com/39554623/85937357-a45e2b80-b93d-11ea-94b0-fdc43d4a012b.png'>
</p>
<br>

- Allocation strategies
  - First fit: Allocate from the **first** hole that is big enough
  - Best fit: Allocate from the **smallest** hole that is big enough
    - 작은 청크들이 계속해서 만들어지면서 worst external fragmentation이 발생 → 반대로 제일 큰 청크에서부터 잘라보면? Worst fit
  - Worst fit: Allocate from the **largest** hole

## Segmentation

- An extension of variable partitions

- Divide address space into logical **segments**
  - **Multiple segments per process**

- Each segment corresponds to logical entry in address space  
  - Code, data, stack, heap, …

- Users (or processes) view memory as **a collection of variable-sized segments**
  - Virtual address: <segment #, offset>

<br>
<p align = 'center'>
<img width = '800' src = 'https://user-images.githubusercontent.com/39554623/85937510-2733b600-b93f-11ea-8bae-bd4232a84d98.png'>
</p>
<br>

- Each process has its own **segment table**
  - Maximum # of rows and column fields vary between architectures
  - Can be located with **segment-table base register(STBR)** in CPU
  - Should be saved/restored during context switch

- Segment ID can be either explicit or implicit
  - Explicit: <segment ID, offset>
    - <0x01, 0x2a31>, <0x21, 0x23c2>
  - Implicit: Use n-MSBs as segment ID
    - 0x012a31, 0x2123c2

### 장단점

#### 장점

> 하나의 프로세스가 하나의 큰 Chunk로 들어갈 필요없이 여러 개의 작은 Chunk로 쪼개져서 여기저기 나누어 쓸 수 있다.

- Enable sparse allocation of address space
  - Can grow and shrink stack and heap independently
  - Can **dynamically** relocate each segment
    - By using `Dir`

- Easy to **protect segments**
  - Different protection bits for different segments
    - **Read-only** for code

#### 단점

> 여전히 External fragmentation 발생

- Still, should be allocated contiguously
  - `#` of supported segments vs. **segment table size overhead**
    - segment table은 해당하는 프로세스의 context → context switch & save overhead가 크다.
  - External fragmentation


## 요약

- Address space

- Contiguous memory allocation
  - Fixed partitioning
  - Variable partitioning
  - Segmentation

- Internal fragmentation vs. external fragmentation