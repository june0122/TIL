# Synchronization (3) - Classical Problems of Synchronization

- Bounded-buffer problem
- Reader and writers problem
- Dining-philosophers problem

## Bounded Buffer Problem

- *a.k.a*  Producer/consumer problem
  - There is a set of resource buffers shared by producers and consumers
  - **Producers** insert resources into the buffer
    - Output, disk blocks, memory pages, etc.
  - **Consumers** remove resources from the buffer
    - Whatever is generated by the producer
  - Producers and consumers execute at different rates
    - Tasks are independent
    - The buffer allows each to run without explicit hand-off

- Should make sure that the producer does not overflow the buffer and
make sure that the consumer does not pull from an empty buffer

### Bounded Buffer in Shared Memory

- **A circular buffer** with two logical pointers

<br>
<p align = 'center'>
<img width = '200' src = 'https://user-images.githubusercontent.com/39554623/85411288-1aac0800-b5a3-11ea-8267-5b52252ce23a.png'>
</p>


```c
#define BUFFER_SIZE 8
typedef struct {
    ...
} item;

item buffer[BUFFER_SIZE];
int in = 0;     /* free position */
int out = 0;    /* next available item */
```

- “in” points to the **next free** position in the buffer
- “out” points to the **first full** position in the buffer
- The buffer is **empty** when `in == out`
- The buffer is **full** when `((in + 1) % BUFFER SIZE) == out`
- Can only use BUFFER_SIZE-1 elements

<br>
<p align = 'center'>
<img width = '550' src = 'https://user-images.githubusercontent.com/39554623/85415744-a96f5380-b5a8-11ea-8977-a90126c42772.png'>
</p>
<br>

### Bounded Buffer Problem

> No synchronization

- 위의 예제는 buffer의 상태를 in과 out의 pointing 위치를 통해 알았다면, 아래의 예제는 `count` 변수를 추가하여 buffer 내부의 개수를 알 수 있게 함.

<br>
<p align = 'center'>
<img width = '600' src = 'https://user-images.githubusercontent.com/39554623/85416874-f142aa80-b5a9-11ea-8596-5a7563dab574.png'>
</p>
<br>

- synchronization 문제가 매우 많은 코드
  - Producer 여러 개가 동시에 값을 쓸 때
  - Consumer 여러 개가 동시에 접근할 때 race condition 발생
  - Producer, Consumer가 동시에 들어올 때
  - etc...

> Implementation with **mutex**

<br>
<p align = 'center'>
<img width = '600' src = 'https://user-images.githubusercontent.com/39554623/85416962-09b2c500-b5aa-11ea-86f2-7c8ec43bf3e4.png'>
</p>
<br>

> Implementation with **semaphores**

<br>
<p align = 'center'>
<img width = '600' src = 'https://user-images.githubusercontent.com/39554623/85419324-e8070d00-b5ac-11ea-9e14-3303723b634a.png'>
</p>
<br>

## Readers-Writers Problem

- Sharing resource among multiple readers and writers
  - An object is shared among several threads
  - Some threads only read the object, others only write it
  - We can allow **multiple readers** at a time (성능을 최대화시키기 위해 하나의 리소스에 대해 Reader는 여러 개가 허용이 됨)
  - We can only allow **one writer** at a time (Writer는 Reader, 다른 Writer들과 동시에 허용되지 않는다.)

### Implementation with semaphores (Binary semaphore ≈ mutex)
  - readcount : # of threads reading object
  - mutex : control access to readcount
  - rw : exclusive writing or reading

> 아래의 예제에서 실질적으로 `wait()` → `lock()`, `signal()` → `unlock()` 이다.

<br>
<p align = 'center'>
<img width = '600' src = 'https://user-images.githubusercontent.com/39554623/85421601-94e28980-b5af-11ea-8d39-a3d8ecf4cb9d.png'>
</p>

### 위 예제의 문제점들

- writer는 들어온 reader가 모두 빠져나가야지만 들어올 수 있다. (**readcount == 0**)
  - reader가 끊임없이 들어오는 환경에선 writer가 무한히 기다리다 starvation이 발생한다.
- If there is a writer
  - The first reader blocks on rw
  - All other readers will then block on mutex
- Once a writer exits, all readers can fall through
  - Which reader gets to go first?
- The last reader to exit signals waiting writer
  - Can new readers get in while writer is waiting?
- When a writer exits, if there is both a reader and writer waiting, which one goes next is up to scheduler

## Dining Philosophers Problem

> 철학자 : Task, 포크 : shared resource.

> Mutiple tasks와 multiple shared resources에 대해서 multiply acquire할 때 order를 잘못하면 deadlock이 발생할 수 있다.

<br>
<p align = 'center'>
<img width = '350' src = 'https://user-images.githubusercontent.com/39554623/85423713-fb68a700-b5b1-11ea-9728-c6f2863b22cd.png'>
</p>
<br>

- A classic synchronization problem by Dijkstra, 1965

- Each philosopher repeats forever:
  - Thinking
  - Pick up two forks (chopsticks)
  - Eating
  - Put down two forks (chopsticks)

- Pick one fork at a time

### A simple solution

<br>
<p align = 'center'>
<img width = '600' src = 'https://user-images.githubusercontent.com/39554623/85423938-45ea2380-b5b2-11ea-9787-8c3a82ee2ac8.png'>
</p>
<br>

### A deadlock-free solution

<br>
<p align = 'center'>
<img width = '600' src = 'https://user-images.githubusercontent.com/39554623/85423964-4edaf500-b5b2-11ea-9aba-fe80ebc9d2d6.png'>
</p>
<br>

- `if (i == (N-1)) { ... }`
  - 왼쪽의 포크를 먼저 잡고 그 다음에 오른쪽의 포크를 잡는데, 마지막 차례의 철학자는 오른쪽 포크부터 잡게 한다.
  - **circular wait**를 깨면서 Dining Philosophers Problem이 발생하지 않는다.

## Deadlock

- Two or more tasks are waiting indefinitely for an event that only one of the waiting processes can make

<br>
<p align = 'center'>
<img width = '450' src = 'https://user-images.githubusercontent.com/39554623/85424430-e0e2fd80-b5b2-11ea-9dea-8e9b10600fd8.png'>
</p>
<br>