# CHAPTER 1. 핵심 개념 소개

> 소스 파일 컴파일 시 추천 명령어

```
$ gcc -Wall -Wextra -02 -g -o snippet snippet.c
```

- snippet.c 라는 소스파일을 유효하면서도 과하지 않은 최적화, 그리고 디버깅 옵션을 활성화하여 실행 가능한 바이너리 파일인 snippet으로 컴파일 한다.

### 시스템 프로그래밍

- 커널 및 핵심 시스템 라이브러리를 직접 사용하면서 하위 레벨에서 동작하는 시스템 소프트웨어를 작성하는 기술을 일컫는다.

- 시스템 소프트웨어의 예시

  - 셸, 텍스트 편집기, 컴파일러, 디버거, 시스템 유틸리티 및 시스템 데몬

  - 네트워크 서버, 웹 서버, 데이터베이스 → 주로 커널과 C 라이브러리를 이용

### 리눅스 시스템 프로그래밍

- 리누스 토르발스(Linus Torvalds)가 처음 개발

- 리눅스는 유닉스의 목표와 철학을 공유하고 있지만, 엄밀히 말하자면 리눅스는 유닉스가 아니다.

  - 핵심은 다른 유닉스 시스템과 동일하나, 추가적인 시스템 콜 지원과 명료한 동작 특성, 새로운 기능을 제공함으로써 다른 전통적인 유닉스 시스템과 차별화

## 1.1 시스템 프로그래밍

### 1.1.1 시스템 프로그래밍을 배워야 하는 이유

- 시스템 프로그래밍을 이해해야 작성하는 코드가 작동하는 레벨과 관계없이 더 나은 성능을 이끌어 낼 수 있다.

- 애플리케이션 프로그래밍에서는 트렌드가 변화하고 있음에도 유닉스와 리눅스 코드의 대부분은 시스템 레벨에서 작성된다.

  - 이 코드들은 대부분 C와 C++이며 C 라이브러리와 커널에서 제공하는 인터페이스를 사용하고 있다.

### 1.1.2 시스템 프로그래밍의 주춧돌

- 시스템 콜
  
- C 라이브러리
  
- C 컴파일러

### 1.1.3 시스템 콜

> **시스템 콜** 이란 운영체제에 리소스나 서비스를 요청하려고 **사용자 영역에서 시작해서 커널 내부로 들어가는 함수 호출**

- 사용자 영역 : 텍스트 편집기나 게임 등

- 시스템 프로그래밍은 시스템 콜에서 시작해서 시스템 콜로 끝난다.

- `read()`, `write()` 같은 익숙한 함수에서부터 `get_narea()`, `set_tid_address()` 같은 생소한 함수까지 범위가 다양


- 리눅스에 구현된 시스템 콜은 다른 대부분의 운영체제 커널에서 제공하는 시스템 콜보다 더 **적다.**

   - x86-62 아키텍쳐의 리눅스 시스템 콜은 약 300여 개인데 비해 마이크로소프트 윈도우에는 수천여 개의 시스템 콜이 있다.

- 리눅스 커널에서는 표준 시스템 콜을 Alpha, x86-64, PowerPC 같은 **개별 아키텍쳐별로 확장하여 구현**하고 있다.

#### 시스템 콜 호출하기

- 사용자 영역의 애플리케이션을 커널 영역으로 **직접 연결하는 것은 불가능**하다.

  - **보안과 안정성의 이유로** 애플리케이션은 커널 코드를 직접 실행하거나 커널 내부 데이터를 조작할 수 없다.

  - 대신, 애플리케이션이 시스템 콜을 실행하려 한다는 **'시그널'** 을 커널로 보낼 수 있다.

    - 이 매커니즘을 통해야만 커널 내부로 진입하고 커널이 허용한 코드를 실행한다.
    
    - 정확한 매커니즘은 아키텍쳐마다 다르다. 

- 애플리케이션은 실행할 시스템 콜과 매개 변수를 **레지스터<sup id = "a1">[ 1](#f1)</sup>** 를 통해 전달한다. 

  - 시스템 콜은 0부터 시작하는 숫자로 나타내며 시스템 콜을 호출하려면 **레지스터에 해당 시스템 콜을 먼저 저장**해야 함.

    - 예로 i386 아키텍쳐에서 시스템 콜 5번, `open()`을 호출하려면 응용 프로그램은 int 명령을 실행하기 전에 eax 레지스터에 5를 저장해야 한다.
    
    - 매개 변수 전달도 비슷한 방식으로 처리되는데 i386에서는, `ebx, ecx, edx, esi, edi` 레지스터에 순서대로 다섯 개의 매개 변수를 저장한다. 매개 변수가 다섯 개 이상 필요할 때는 레지스터 하나에 나머지 모든 매개 변수를 담은 사용자 영역의 버퍼를 가리키도록 한다. (물론 대부분의 시스템 콜에는 매개 변수가 두어 개만 있다.)

- 아키텍쳐별로 시스템 콜을 처리하는 방식은 다르지만, **기본 원리는 같다.**

  - 커널이 **시스템 콜을 처리하는 자세한 내용까지 알 필요는 없다.** 이런 지식은 아키텍쳐의 **표준 콜링 컨벤션**(standard calling convention, 표준 호출 규약)에 녹아 있으며 컴파일러와 C 라이브러리에서 **자동으로 처리**된다,

### 1.1.4 C 라이브러리

- C 라이브러리 (libc) 는 유닉스 애플리케이션의 핵심이다.

- 최신 리눅스 시스템에서는 **GNU C 라이브러리인 glibc 가 제공**되는데 `지-립-씨` 혹은 `글립-씨`라 읽는다.

- GNU C 라이브러리는 C 라이브러리뿐만 아니라 시스템 콜에 대한 래퍼와 스레드 지원, 그리고 기본 애플리케이션 기능에 대한 내용도 포함한다.


### 1.1.5 C 컴파일러

- 리눅스는 표준 C 컴파일러로 GNU 컴파일러 컬렉션(GCC)을 제공하는데, 원래 gcc는 C 컴파일러인 cc의 GNU 버전이었다.

- gcc는 GNU C Compiler의 약자였으나 세월이 흐르면서 여러 가지 언어를 지원하게 되었고, 현재의 gcc는 GNU 컴파일러군을 총칭하는 일반적인 이름이 되었다. 

- 하지만 **gcc**는 **C 컴파일러의 실행 파일 이름**이기도 하다. → 본 책에서 언급되는 gcc는 C 컴파일러 실행 파일인 gcc를 의미한다. 

<br>

## 1.2 API와 ABI <sup id = "a2">[ 2](#f2)</sup>

> 시스템 레벨에서 **호환성에 영향**을 주는 2가지

- API (Application Programming Interface, 응용 프로그램 프로그래밍 인터페이스)

- ABI (Application Binary Interface, 응용 프로그램 이진 인터페이스)

둘 다 서로 다른 컴퓨터 소프트웨어 간의 인터페이스를 정의하고 기술한다.

### 1.2.1 API

> 소프트웨어의 **소스 코드 레벨에서 서로 인터페이스 하는 방식**을 정의

- 일반적으로 API의 표준 인터페이스는 함수이며 상위 레벨의 소프트웨어에서 더 하위 레벨의 소프트웨어를 호출할 수 있다.

- API는 양쪽 소프트웨어 모두가 API를 준수할 경우에만 동작하며 소스 코드 수준에서 호환된다.

  - 즉, API의 구현체와 관계없이 **그 API를 따르기만 한다면 성공적으로 컴파일**된다.


### 1.2.2 ABI

> API가 소스 코드 수준의 인터페이스를 정의한다면, ABI는 특정 아키텍쳐 간에서 동작하는 **소프트웨어 간의 바이너리 인터페이스를 정의**

```
  커 널 <---> 애플리케이션 <---> 라이브러리
```

- ABI는 애플리케이션 내에서의 상호 동작, 커널과 애플리케이션, 혹은 애플리케이션과 라이브러리 간의 상호 동작에 대해서 정의한다.

- API보다 ABI가 낮은 수준(binary)의 인터페이스이다.

- **API**가 **소스 코드 수준의 호환성을 보장**한다면, **ABI**는 **바이너리의 호환성을 보장**한다.
 
  - 이는 **오브젝트 코드를 다시 컴파일하는 수고 없이** 같은 ABI를 지원하는 시스템이라면 **동일한 기능을 수행하도록 보장**한다.
  
  - WINDOWS 98에서 돌아가던게 XP에서도 돌아가는 이유는 MS에서 ABI를 지원하기 때문이다.

<br>

- ABI는 콜링 컨벤션, 바이트 순서, 레지스터 활용, 시스템 콜 실행, 라이브러리 링크, 라이브러리 동작 방식, 바이너리 오브젝트 형식 같은 내용과 관련이 있다.

  - 예를 들어, 콜링 컨벤션은 함수가 실행되는 방식, 인자가 함수로 전달되는 방식, 레지스터에 값을 저장하는 방식, 함수를 호츨하는 측에서 반환값을 가져가는 방식 등을 정의한다.

<br>

- 리눅스에서는 아키텍처마다 다른 고유의 ABI를 가지고 있다. 그래서 실제로 Alpha, x86-64 같은 아키텍처 이름으로 특정 ABI를 지칭하기도 한다.

- ABI는 말하자면 리눅스 같은 **운영체제**와 x86-64 같은 **아키텍처 양쪽 모두의 기능**이다.

- ABI는 컴파일러, 링커 같은 툴체인에 의해서 강제되므로 겉으로 드러나는 일은 없다.

  - 하지만 ABI에 대한 지식이 있으면 **프로그램을 좀 더 최적화**할 수 있으며, 시스템 프로그래밍의 한 종류인 **어셈블리 코드나 툴체인 자체를 개발**할 때는 ABI를 꼭 알아야 한다.

### 호환

- 서로 다른 버전의 두 라이브러리가 같은 ABI를 가지고 있을 때 **binary compatible** 하다고 한다.

- ABI는 바뀌었는데 API는 그대로일 때, **source compatible** 하다고 한다.

  - 이것만으로는 동작의 보장이 안되므로 ABI가 바뀌면 컴파일을 다시 해야 한다.

### 결론

- ABI 호환성을 유지하면 라이브러리 유지·보수가 편해진다. ABI 호환성이 깨졌을 경우는 다시 컴파일하면 된다.


## 1.3 표준

- 유닉스 시스템 프로그래밍은 오래된 기술이다. 유닉스 프로그래밍의 기초는 지난 수십 년간 크게 바뀌지 않았지만, 동작 방식은 바뀌고 있으며 새로운 기능도 계속 추가된다.

- 이런 혼돈을 바로 잡기 위해서 표준 그룹은 공식적인 시스템 인터페이스를 표준으로 만들었다.

- 다양한 표준안이 존재하지만 기술적으로 말하자면 리눅스는 어떤 표준에도 맞지 않는다.

- 대신 리눅스는 **가장 중요하고 유력한 표준인 POSIX(Portable Operating System Interface)와 SUS(Single UNIX Specification) 호환을 지키려고 노력**한다.

### 1.3.1 POSIX와 SUS 표준 이야기

- 1980년대 중반 IEEE는 유닉스 시스템을 위한 시스템 수준의 인터페이스 표준화를 시작했다.

- 자유 소프트웨어 재단(FSF, Free Software Foundation)의 창립자인 리차드 스톨만(Richard Stallman)은 POSIX를 표준안 이름으로 제안했다.

- 모든 POSIX 핵심 표준은 POSIX.1로 줄여 부르며 2008년 개정판이 가장 최신 버전이다.

- SUS는 POSIX 표준에 비해 비용이 저렴(무료)했던 이유로 빠르게 인기를 얻었고, 오늘날 SUS는 최신 POSIX 표준을 포함한다.

### 1.3.2 C 언어 표준

1978년 출간된 데니스 리치(Dennis Ritchie)와 브라이언 커니핸(Brian Kernighan)의 유명한 저서, 『C 언어 프로그래밍』은 출간 이후 몇 년 동안 그 자체로 C 언어의 표준 역할을 했는데 이를 **K&R C** 라고 한다.

(이하 39p 참조.)

### 1.3.3 리눅스와 표준

- 앞서 이야기했듯, 리눅스는 POSIX와 SUS 호환을 지향한다.

- 다양한 리눅스 배포판 중에서 LSB(Linux Standard Base)는 리눅스 시스템 대부분을 표준화한다.

  - LSB는 몇몇 리눅스 업체가 리눅스 파운데이션의 후원으로 진행하고 있는 프로젝트이다.

  - LSB는 POSIX와 SUS를 확장해서 독자적인 표준 몇 가지는 추가했다.

  - LSB는 바이너리 표준을 제공함으로써 오브젝트 코드가 호환 가능한 시스템에서는 변경 없이 실행할 수 있게 해준다.

## 1.4 리눅스 프로그래밍의 개념

- 리눅스를 포함한 모든 유닉스 시스템은 **상호 간의 추상화와 인터페이스를 제공**한다.

  - 이러한 공통성이 곧 유닉스를 의미한다.

  - **파일과 프로세스, 파이프와 소켓을 다루기 위한 인터페이스 등** 이런 것들이 유닉스의 핵심이다.

### 1.4.1 파일과 파일 시스템

#### 일반 파일

> **바이트 스트림**이라고 부르는 연속적으로 나열된 바이트 배열에 저장된 데이터를 의미

- 리눅스에는 파일을 위한 특별한 자료구조가 없다.

  - 이 데이터에는 어떠한 값이라도 들어갈 수 있으며 어떤 구조로 저장해도 상관없다.
  
  - 시스템 수준에서 살펴보면 리눅스는 바이트 스트림 외에 어떤 자료구조도 강제하지 않는다.

  - 바이트 스트림(Byte Stream)의 경우에는 원시 Byte를 그대로 주고 받겠다는 의미를 담고 있다.

- 파일은 바이트를 읽고 쓰는 것이 가능하다.

  - 이런 작업은 파일 내부의 위치를 지정해서 수행할 수 있는데, 이 위치는 **파일 오프셋**<sup> file offset</sup><sup id = "a3">[ 1 ](#f3)</sup>  혹은 파일 위치<sup>file position</sup>라고 한다.

  - 파일이 처음 열리면 파일 오프셋은 0 이다.

  - 파일 오프셋의 최댓값은 이 오프셋을 저장하기 위해 사용하는 C 타입의 크기로 결정되며 최신 리눅스 시스템에서는 64비트 값이다.

- **파일 크기**는 바이트 단위로 측정되며, 이를 파일 길이라 한다.

  - `파일 크기 = 바이트 배열의 크기`  

  - `최대 파일 길이 = 최대 파일 오프셋 값`, 커널에서 파일을 관리하기 위해 사용하는 C 타입의 크기로 제한

    - 일부 파일 시스템에서는 이보다 더 작은 크기로 최대 길이를 제약하는 경우도 존재

- 하나의 파일은 다른 프로세스나 심지어 동일한 프로세스에서 한 번 이상 열 수 있다.

  - 파일은 열릴 때마다 고유한 파일 디스크립터를 반환한다. (프로세스에서는 파일 디스크립터 공유 가능)

  - 커널은 파일에 대한 **동시 접근**을 막지 않는다.

    - 이와 같은 동시 접근은 각각의 연산 순서에 따라 **다른 결과를 발생시키며 예측이 불가능**하다. 그러므로 사용자 영역의 프로그램은 이런 **파일 동시 접근을 회피할 수 있도록 항상 신경** 써야 한다.

- 파일은 파일 이름이 아닌, **inode**<sup>information node(아이노드)</sup>라고 하는 파일시스템 내에서만 고유한 정수 값으로 참조된다.

  - 이 값은 inode 번호라고 하며 ino<sup>i-number</sup>라고 줄여 쓰기도 한다.

  - inode는 변경된 날짜, 소유자, 타입, 길이, 데이터 저장 위치 같은 파일에 관련된 메타데이터를 저장하고 있지만, 파일 이름은 저장하지 않는다.

  - inode는 유닉스 **파일시스템에서 디스크에 저장된 물리적인 객체**임과 동시에 **리눅스 커널에서 자료구조로 표현되는 논리적인 개념**이기도 하다.

<br>

#### 디렉터리와 링크

- inode 번호로 파일에 접근하려면 번거로운 데다 잠재적 보안 위협까지 있어서 보통 **사용자 영억에서 파일에 접근할 때는 inode 대신 파일 이름을 사용**한다.

- **디렉터리**는 파일에 접근하기 위한 이름을 제공하는데 디렉터리는 inode 대신에 **사람이 읽을 수 있는 이름**으로 나타낸다.

  - 이 이름과 inode의 쌍을 **링크**라고 한다.

  - 개념적으로 디렉터리는 일반 파일과 유사한 모습이지만 **이름과 inode의 맵핑만 저장**한다는 점에서 차이가 있다.

    - 커널은 이런 맵핑을 사용해서 이름으로 inode를 찾는 작업을 수행한다.

```
 [사용자 영역 애플리케이션] 특정 파일을 열겠다고 요청

                      ↓

      [커널] 파일 이름으로 inode 번호 얻음
                      
                      ↓

      [커널] 얻은 inode 번호로 inode를 찾음
```

- 디렉터리 내부의 링크 역시 다른 디렉터리의 inode를 가리킬 수 있다.

  - 즉, 디렉터리는 다른 디렉터리 내부에 존재할 수 있고 계층적인 구조를 형성할 수 있다.

  - 이를 활용해 `/home/blackbeard/concorde.png`처럼 우리에게 친숙한 파일 경로를 사용할 수 있는 것이다.

    - 이런 파일 경로를 열겠다고 요청하면 커널은 해당 파일 경로에 속한 각 **디렉터리 엔트리**<sup>directory entry</sup>(커널 내부에서는 **dentry**라고 부른다)를 탐색해서 다음 항목의 inode를 찾는다.

    - 리눅스 커널은 dentry 캐시를 사용해서 디렉터리 찾기 결과를 저장하고 나중에 일시적인 지역성을 활용해 탐색 속도를 높인다.

- 비록 디렉터리를 일반 파일처럼 취급하지만, 커널은 사용자 영역에서 디렉터리를 일반 파일처럼 열고 조작하지 못하도록 **제한**한다.

  - 그래서 디렉터리는 **특수한 시스템 콜을 활용해서 조작**해야 하는데, 이를 위한 시스템 콜로는 **링크 추가와 삭제**가 있다.

  - 사용자 영역에서 커널의 중재 없이 디렉터리를 조작할 수 있게 하면 아주 단순한 오류가 발생해도 파일시스템 전체를 망가뜨릴 수 있다.

<br>

#### 하드 링크 (hard link) & 심벌릭 링크 (symbolic link)

https://jybaek.tistory.com/578

https://github.com/whdlgp/system_programming_pra/wiki/%EC%A2%80-%EB%8D%94-%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90%EC%84%9C-%ED%8C%8C%EC%9D%BC-%EB%8B%A4%EB%A4%84%EB%B3%B4%EA%B8%B0(%EB%A7%81%ED%81%AC)

<br>
<p align = "center">
<img src = "https://user-images.githubusercontent.com/39554623/58148455-cea0dc80-7c99-11e9-89fd-228c0d695ce8.png">
</p>
<br>

> 하드 링크

- 원본 파일과 **동일한 inode**를 가진다.

  - 그렇기 때문에 원본 파일이 삭제되더라도 원본 파일의 inode를 가지고 있는 링크 파일은 여전히 사용이 가능하다.

- 리눅스 시스템은 링크를 해제할 때마다 inode와 관련 자료를 삭제할 수 없다.

  - 파일시스템 내에 다른 하드 링크가 존재한다면, 모든 링크가 삭제될 때까지 파일을 삭제하지 못하도록 보장하기 위해 각 inode는 파일시스템 내부에 **링크 카운터**를 두어 **자신을 가리키는 링크 개수를 추적**한다.
  
  - 파일 이름의 링크가 해제하면 링크 카운터가 하나 감소하며 **링크 카운트가 0이 되면 파일시스템에서 inode와 관련 자료를 실제로 삭제**한다.

  - `같은 inode를 가르키는 서로 다른 이름으로 원본이라는 개념이 모호하다. → 원본은 존재하는게 아닌가?`

> 심벌릭 링크

- 원본 파일의 **이름을 가리키는 링크**이다.

  - 그렇기 때문에 원본 파일이 사라지게 되면 역할을 수행할 수 없다.

  - 장점은 전혀 다른 파일이라도 원본 파일과 이름이 같다면 계속 사용이 가능하다는 것이다.

    - 주로 dynamic library의 so 파일과 연계해서 사용하게 된다.


```
june0122@ubuntu:~/linux/link$ echo "This is test file" > test
june0122@ubuntu:~/linux/link$ ls
test
june0122@ubuntu:~/linux/link$ cat test
This is test file
june0122@ubuntu:~/linux/link$ vi test
june0122@ubuntu:~/linux/link$
june0122@ubuntu:~/linux/link$ echo add new line >> test
june0122@ubuntu:~/linux/link$ ls
test
june0122@ubuntu:~/linux/link$ cat test
This is test file
add new line
june0122@ubuntu:~/linux/link$ more test
This is test file
add new line
june0122@ubuntu:~/linux/link$ ls -ali test
530554 -rw-rw-r-- 1 june0122 june0122 31 May 22 05:16 test
june0122@ubuntu:~/linux/link$ ln -s test aaaa
june0122@ubuntu:~/linux/link$ ls
aaaa  test
june0122@ubuntu:~/linux/link$ vi aaaa
june0122@ubuntu:~/linux/link$ ln test bbbb
june0122@ubuntu:~/linux/link$ ls
aaaa  bbbb  test
june0122@ubuntu:~/linux/link$ ls -i
530555 aaaa  530554 bbbb  530554 test
june0122@ubuntu:~/linux/link$ ls -ali
total 16
530553 drwxrwxr-x 2 june0122 june0122 4096 May 22 05:22 .
528258 drwxrwxr-x 3 june0122 june0122 4096 May 22 05:04 ..
530555 lrwxrwxrwx 1 june0122 june0122    4 May 22 05:21 aaaa -> test
530554 -rw-rw-r-- 2 june0122 june0122   31 May 22 05:21 bbbb
530554 -rw-rw-r-- 2 june0122 june0122   31 May 22 05:21 test
june0122@ubuntu:~/linux/link$ rm test
june0122@ubuntu:~/linux/link$ ls
aaaa  bbbb
june0122@ubuntu:~/linux/link$ cat aaaa
cat: aaaa: No such file or directory
june0122@ubuntu:~/linux/link$ cat bbbb
This is test file
add new line

```




<br>

#### 특수 파일

<br>

#### 파일 시스템과 네임스페이스



### 1.4.2 프로세스


---------------------------------------------------------

## <b id = "f1"><sup>1 </sup></b>레지스터(Register)[ ↩](#a1)

- CPU가 프로세스를 실행하기 위해서는 프로세스를 CPU에 적재시켜야 할 것이다. 그리고 이렇게 흩어져 있는 명령어 집합(Instruction Set)과 데이터들을 적절하게 집어내어 읽고 저장하기 위해서는 여러 가지 저장 공간이 필요하다. 또한 CPU가 재빨리 읽고 쓰기를 해야 하는 데이터들이므로 CPU 내부에 존재하는 메모리를 사용한다. 이러한 공간을 **레지스터(Register)** 라고 한다.

- 레지스터는 그 목적에 따라서 **4개의 종류**로 나누어진다.
 
  - 범용 레지스터 (General-Purpose Register)
  - 세그먼트 레지스터 (Segment Register)
  - 상태 플래그 레지스터 (Program Status and Control Register)
  - 명령 포인터 레지스터 (Instruction Pointer Register)

<br>
<p align = "center">
<img src = "https://user-images.githubusercontent.com/39554623/58073975-fed77500-7bde-11e9-940c-60b5327531bf.png">
</p>
<br>

### 범용 레지스터 (General-Purpose Register)

> 범용 레지스터는 **프로그래머가 임의로 조작할 수 있게 허용되어 있는 레지스터** 이다.
  
- 일종의 4개의 32bit 변수라고 생각하면 된다.

- 예전의 16bit 시절에서는 각 레지스터를 `AX, BX, CX, DX ..` 등으로 불렀지만 32bit 시스템으로 전환되면서 **E (Extended)** 가 앞에 붙어 `EAX, EBX, ECX, EDX ..` 등으로 불린다.

- 상위 8 비트는 High라서 `H` 가 붙고, 하위 8 비트는 Low라서 `L` 이 붙는다고 생각하면 외우기 쉽다.

<br>
<p align = "center">
<img src = "https://user-images.githubusercontent.com/39554623/58071480-d13afd80-7bd7-11e9-9f04-c2e62939d9f0.png">
</p>
<br>

> EAX (Extended Accumulator Register)

산술연산 명령에서 상수/변수 값을 저장하거나 함수의 리턴 값이 저장되는 용도로도 사용된다.

> EBX (Extended Base Register)

EBX는 DS 세그먼트에 대한 포인터를 주로 저장하고 ESI나 EDI와 결합하여 인덱스에 사용된다. EBX는 메모리 주소 지정을 확장하기 위해 인덱스로 사용될 수 있는 유일한 범용 레지스터이다.

> ECX (Extended Counter Register)

 반복 명령어 사용 시 반복 카운터로 사용된다. ECX 레지스터에 반복할 횟수를 지정해 놓고 반복 작업을 수행하게 된다.

> EDX (Extended Data Register)

 데이터 레지스터이다. 입, 출력 포인터 값을 저장할 때 사용한다. 

> ESI (Extended Source Index)

 데이터 복사나 조작 시 Source Data의 주소가 저장된다. ESI 레지스터가 가리키는 주소의 데이터를 EDI 레지스터가 가리키는 주소로 복사하는 용도로 많이 사용된다.

> EDI (Extended Destination Index)

 복사 작업 시 Destination의 주소가 저장된다. 주로 ESI 레지스터가 가리키는 주소의 데이터가 복사된다.

> ESP (Extended Stack Pointer)

 하나의 스택 프레임의 끝 지점 주소가 저장된다. PUSH, POP 명령어에 따라서 ESP의값이 4Byte씩 변한다.

> EBP (Extended Base Pointer)

 하나의 스택 프레임의 시작 지점 주소가 저장된다. 현재 사용되는 스택 프레임이 소멸되지 않는 동안 EBP 의 값은 변하지 않는다. 현재의 스택 프레임이 소멸되면 이전에 사용되던 스택 프레임을 가리키게 된다.

<br>

### 세그먼트 레지스터 (Segment Register)

- 세그먼트 레지스터는 총 6개(CS, SS, DS, ES, FS, GS)이고 각 크기는 16비트이다.

- 각 세그먼트 레지스터가 가리키는 세그먼트 디스크립터와 가상메모리가 조합되어 선형주소가 되며, 페이징 기법에 의해서 선형 주소가 최종적으로 물리주소로 변환됩니다.

  - 만약 OS에서 페이징을 사용하지 않는다면 선형주소는 그대로 물리주소가 됩니다.

> CS(Code Segment)

 코드 영역의 시작 주소를 저장한다.

> DS(Data Segment)

 데이터 영역의 시작 주소를 저장한다.

> ES(Extra Segment)

 비디오 영역의 시작 주소를 저장한다.

> FS

 기타 영역의 시작 주소를 저장한다.

> SS(Stack Segment)

 스택 영역의 시작 주소를 저장한다.

<br>

 ### 명령 포인터 레지스터 (Instruction Pointer Register)

 > EIP (Extended Instruction Pointer)

 - 다음에 실행해야 할 명령어가 존재하는 메모리 주소가 저장된다.

 - 현재 명령어를 실행 완료한 후에 EIP 레지스터에 저장되어 있는 주소에 위치한 명령어를 실행하게 된다. 실행 전 EIP 레지스터에는 다음 실행해야 할 명령어가 존재하는 주소의 값이 저장된다.

<br>

## <b id = "f2"><sup>2 </sup></b>[라이브러리 API, ABI 뜻의 비교](https://eine.tistory.com/entry/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-API-ABI-%EB%9C%BB-%EB%B9%84%EA%B5%90-%EC%A0%95%EB%A6%AC) [ ↩](#a2)

보통 외부 컴포넌트의 경우 라이브러리 형태로 제공받는 경우가 많아서 라이브러리와 API의 뜻을 햇갈려하는 경우가 많다.

- **라이브러리**는 이러한 **컴포넌트 자체**를 뜻하고

- **API**는 이 **컴포넌트를 활용하는 규약**이라고 보면 된다.

<br>

## <b id = "f3"><sup>3 </sup></b>오프셋(offset)[ ↩](#a3)

- 컴퓨터 과학에서 배열이나 자료 구조 오브젝트 내의 오프셋(offset)은 일반적으로 동일 오브젝트 안에서 **오브젝트의 처음부터 주어진 요소나 지점까지의 변위차**를 나타내는 정수형이다.

  - 이를테면, 문자 A의 배열이 abcdef를 포함한다면 'c' 문자는 A 시작점에서 2의 오프셋을 지닌다고 할 수 있다.

  - 어셈블리어와 같은 저급 프로그래밍 언어에서 오프셋은 **상대 주소(relative address)**로 부른다.
