# CHAPTER 1. 핵심 개념 소개

> 소스 파일 컴파일 시 추천 명령어

```
$ gcc -Wall -Wextra -02 -g -o snippet snippet.c
```

- snippet.c 라는 소스파일을 유효하면서도 과하지 않은 최적화, 그리고 디버깅 옵션을 활성화하여 실행 가능한 바이너리 파일인 snippet으로 컴파일 한다.

### 시스템 프로그래밍

- 커널 및 핵심 시스템 라이브러리를 직접 사용하면서 하위 레벨에서 동작하는 시스템 소프트웨어를 작성하는 기술을 일컫는다.

- 시스템 소프트웨어의 예시

  - 셸, 텍스트 편집기, 컴파일러, 디버거, 시스템 유틸리티 및 시스템 데몬

  - 네트워크 서버, 웹 서버, 데이터베이스 → 주로 커널과 C 라이브러리를 이용

### 리눅스 시스템 프로그래밍

- 리누스 토르발스(Linus Torvalds)가 처음 개발

- 리눅스는 유닉스의 목표와 철학을 공유하고 있지만, 엄밀히 말하자면 리눅스는 유닉스가 아니다.

  - 핵심은 다른 유닉스 시스템과 동일하나, 추가적인 시스템 콜 지원과 명료한 동작 특성, 새로운 기능을 제공함으로써 다른 전통적인 유닉스 시스템과 차별화

## 1.1 시스템 프로그래밍

### 1.1.1 시스템 프로그래밍을 배워야 하는 이유

- 시스템 프로그래밍을 이해해야 작성하는 코드가 작동하는 레벨과 관계없이 더 나은 성능을 이끌어 낼 수 있다.

- 애플리케이션 프로그래밍에서는 트렌드가 변화하고 있음에도 유닉스와 리눅스 코드의 대부분은 시스템 레벨에서 작성된다.

  - 이 코드들은 대부분 C와 C++이며 C 라이브러리와 커널에서 제공하는 인터페이스를 사용하고 있다.

### 1.1.2 시스템 프로그래밍의 주춧돌

- 시스템 콜
  
- C 라이브러리
  
- C 컴파일러

### 1.1.3 시스템 콜

> **시스템 콜** 이란 운영체제에 리소스나 서비스를 요청하려고 **사용자 영역에서 시작해서 커널 내부로 들어가는 함수 호출**

- 사용자 영역 : 텍스트 편집기나 게임 등

- 시스템 프로그래밍은 시스템 콜에서 시작해서 시스템 콜로 끝난다.

- `read()`, `write()` 같은 익숙한 함수에서부터 `get_narea()`, `set_tid_address()` 같은 생소한 함수까지 범위가 다양


- 리눅스에 구현된 시스템 콜은 다른 대부분의 운영체제 커널에서 제공하는 시스템 콜보다 더 **적다.**

   - x86-62 아키텍쳐의 리눅스 시스템 콜은 약 300여 개인데 비해 마이크로소프트 윈도우에는 수천여 개의 시스템 콜이 있다.

- 리눅스 커널에서는 표준 시스템 콜을 Alpha, x86-64, PowerPC 같은 **개별 아키텍쳐별로 확장하여 구현**하고 있다.

#### 시스템 콜 호출하기

- 사용자 영역의 애플리케이션을 커널 영역으로 **직접 연결하는 것은 불가능**하다.

  - **보안과 안정성의 이유로** 애플리케이션은 커널 코드를 직접 실행하거나 커널 내부 데이터를 조작할 수 없다.

  - 대신, 애플리케이션이 시스템 콜을 실행하려 한다는 **'시그널'** 을 커널로 보낼 수 있다.

    - 이 매커니즘을 통해야만 커널 내부로 진입하고 커널이 허용한 코드를 실행한다.
    
    - 정확한 매커니즘은 아키텍쳐마다 다르다. 

- 애플리케이션은 실행할 시스템 콜과 매개 변수를 **레지스터<sup id = "a1">[ 1](#f1)</sup>** 를 통해 전달한다. 

  - 시스템 콜은 0부터 시작하는 숫자로 나타내며 시스템 콜을 호출하려면 **레지스터에 해당 시스템 콜을 먼저 저장**해야 함.

    - 예로 i386 아키텍쳐에서 시스템 콜 5번, `open()`을 호출하려면 응용 프로그램은 int 명령을 실행하기 전에 eax 레지스터에 5를 저장해야 한다.
    
    - 매개 변수 전달도 비슷한 방식으로 처리되는데 i386에서는, `ebx, ecx, edx, esi, edi` 레지스터에 순서대로 다섯 개의 매개 변수를 저장한다. 매개 변수가 다섯 개 이상 필요할 때는 레지스터 하나에 나머지 모든 매개 변수를 담은 사용자 영역의 버퍼를 가리키도록 한다. (물론 대부분의 시스템 콜에는 매개 변수가 두어 개만 있다.)

- 아키텍쳐별로 시스템 콜을 처리하는 방식은 다르지만, **기본 원리는 같다.**

  - 커널이 **시스템 콜을 처리하는 자세한 내용까지 알 필요는 없다.** 이런 지식은 아키텍쳐의 **표준 콜링 컨벤션**(standard calling convention, 표준 호출 규약)에 녹아 있으며 컴파일러와 C 라이브러리에서 **자동으로 처리**된다,

### 1.1.4 C 라이브러리

- C 라이브러리 (libc) 는 유닉스 애플리케이션의 핵심이다.

- 최신 리눅스 시스템에서는 **GNU C 라이브러리인 glibc 가 제공**되는데 `지-립-씨` 혹은 `글립-씨`라 읽는다.

- GNU C 라이브러리는 C 라이브러리뿐만 아니라 시스템 콜에 대한 래퍼와 스레드 지원, 그리고 기본 애플리케이션 기능에 대한 내용도 포함한다.


### 1.1.5 C 컴파일러

- 리눅스는 표준 C 컴파일러로 GNU 컴파일러 컬렉션(GCC)을 제공하는데, 원래 gcc는 C 컴파일러인 cc의 GNU 버전이었다.

- gcc는 GNU C Compiler의 약자였으나 세월이 흐르면서 여러 가지 언어를 지원하게 되었고, 현재의 gcc는 GNU 컴파일러군을 총칭하는 일반적인 이름이 되었다. 

- 하지만 **gcc**는 **C 컴파일러의 실행 파일 이름**이기도 하다. → 본 책에서 언급되는 gcc는 C 컴파일러 실행 파일인 gcc를 의미한다. 

<br>

## 1.2 API와 ABI <sup id = "a2">[ 2](#f2)</sup>

> 시스템 레벨에서 **호환성에 영향**을 주는 2가지

- API (Application Programming Interface, 응용 프로그램 프로그래밍 인터페이스)

- ABI (Application Binary Interface, 응용 프로그램 이진 인터페이스)

둘 다 서로 다른 컴퓨터 소프트웨어 간의 인터페이스를 정의하고 기술한다.

### 1.2.1 API

> 소프트웨어의 **소스 코드 레벨에서 서로 인터페이스 하는 방식**을 정의

- 일반적으로 API의 표준 인터페이스는 함수이며 상위 레벨의 소프트웨어에서 더 하위 레벨의 소프트웨어를 호출할 수 있다.

- API는 양쪽 소프트웨어 모두가 API를 준수할 경우에만 동작하며 소스 코드 수준에서 호환된다.

  - 즉, API의 구현체와 관계없이 **그 API를 따르기만 한다면 성공적으로 컴파일**된다.


### 1.2.2 ABI

> API가 소스 코드 수준의 인터페이스를 정의한다면, ABI는 특정 아키텍쳐 간에서 동작하는 **소프트웨어 간의 바이너리 인터페이스를 정의**

```
  커 널 <---> 애플리케이션 <---> 라이브러리
```

- ABI는 애플리케이션 내에서의 상호 동작, 커널과 애플리케이션, 혹은 애플리케이션과 라이브러리 간의 상호 동작에 대해서 정의한다.

- API보다 ABI가 낮은 수준(binary)의 인터페이스이다.

- **API**가 **소스 코드 수준의 호환성을 보장**한다면, **ABI**는 **바이너리의 호환성을 보장**한다.
 
  - 이는 **오브젝트 코드를 다시 컴파일하는 수고 없이** 같은 ABI를 지원하는 시스템이라면 **동일한 기능을 수행하도록 보장**한다.
  
  - WINDOWS 98에서 돌아가던게 XP에서도 돌아가는 이유는 MS에서 ABI를 지원하기 때문이다.

<br>

- ABI는 콜링 컨벤션, 바이트 순서, 레지스터 활용, 시스템 콜 실행, 라이브러리 링크, 라이브러리 동작 방식, 바이너리 오브젝트 형식 같은 내용과 관련이 있다.

  - 예를 들어, 콜링 컨벤션은 함수가 실행되는 방식, 인자가 함수로 전달되는 방식, 레지스터에 값을 저장하는 방식, 함수를 호츨하는 측에서 반환값을 가져가는 방식 등을 정의한다.

<br>

- 리눅스에서는 아키텍처마다 다른 고유의 ABI를 가지고 있다. 그래서 실제로 Alpha, x86-64 같은 아키텍처 이름으로 특정 ABI를 지칭하기도 한다.

- ABI는 말하자면 리눅스 같은 **운영체제**와 x86-64 같은 **아키텍처 양쪽 모두의 기능**이다.

- ABI는 컴파일러, 링커 같은 툴체인에 의해서 강제되므로 겉으로 드러나는 일은 없다.

  - 하지만 ABI에 대한 지식이 있으면 **프로그램을 좀 더 최적화**할 수 있으며, 시스템 프로그래밍의 한 종류인 **어셈블리 코드나 툴체인 자체를 개발**할 때는 ABI를 꼭 알아야 한다.

### 호환

- 서로 다른 버전의 두 라이브러리가 같은 ABI를 가지고 있을 때 **binary compatible** 하다고 한다.

- ABI는 바뀌었는데 API는 그대로일 때, **source compatible** 하다고 한다.

  - 이것만으로는 동작의 보장이 안되므로 ABI가 바뀌면 컴파일을 다시 해야 한다.

### 결론

- ABI 호환성을 유지하면 라이브러리 유지·보수가 편해진다. ABI 호환성이 깨졌을 경우는 다시 컴파일하면 된다.


## 1.3 표준

- 유닉스 시스템 프로그래밍은 오래된 기술이다. 유닉스 프로그래밍의 기초는 지난 수십 년간 크게 바뀌지 않았지만, 동작 방식은 바뀌고 있으며 새로운 기능도 계속 추가된다.

- 이런 혼돈을 바로 잡기 위해서 표준 그룹은 공식적인 시스템 인터페이스를 표준으로 만들었다.

- 다양한 표준안이 존재하지만 기술적으로 말하자면 리눅스는 어떤 표준에도 맞지 않는다.

- 대신 리눅스는 **가장 중요하고 유력한 표준인 POSIX(Portable Operating System Interface)와 SUS(Single UNIX Specification) 호환을 지키려고 노력**한다.

### 1.3.1 POSIX와 SUS 표준 이야기

- 1980년대 중반 IEEE는 유닉스 시스템을 위한 시스템 수준의 인터페이스 표준화를 시작했다.

- 자유 소프트웨어 재단(FSF, Free Software Foundation)의 창립자인 리차드 스톨만(Richard Stallman)은 POSIX를 표준안 이름으로 제안했다.

- 모든 POSIX 핵심 표준은 POSIX.1로 줄여 부르며 2008년 개정판이 가장 최신 버전이다.

- SUS는 POSIX 표준에 비해 비용이 저렴(무료)했던 이유로 빠르게 인기를 얻었고, 오늘날 SUS는 최신 POSIX 표준을 포함한다.

### 1.3.2 C 언어 표준

1978년 출간된 데니스 리치(Dennis Ritchie)와 브라이언 커니핸(Brian Kernighan)의 유명한 저서, 『C 언어 프로그래밍』은 출간 이후 몇 년 동안 그 자체로 C 언어의 표준 역할을 했는데 이를 **K&R C** 라고 한다.

(이하 39p 참조.)

### 1.3.3 리눅스와 표준

- 앞서 이야기했듯, 리눅스는 POSIX와 SUS 호환을 지향한다.

- 다양한 리눅스 배포판 중에서 LSB(Linux Standard Base)는 리눅스 시스템 대부분을 표준화한다.

  - LSB는 몇몇 리눅스 업체가 리눅스 파운데이션의 후원으로 진행하고 있는 프로젝트이다.

  - LSB는 POSIX와 SUS를 확장해서 독자적인 표준 몇 가지는 추가했다.

  - LSB는 바이너리 표준을 제공함으로써 오브젝트 코드가 호환 가능한 시스템에서는 변경 없이 실행할 수 있게 해준다.

## 1.4 리눅스 프로그래밍의 개념

- 리눅스를 포함한 모든 유닉스 시스템은 **상호 간의 추상화와 인터페이스를 제공**한다.

  - 이러한 공통성이 곧 유닉스를 의미한다.

  - **파일과 프로세스, 파이프와 소켓을 다루기 위한 인터페이스 등** 이런 것들이 유닉스의 핵심이다.

### 1.4.1 파일과 파일 시스템

#### 일반 파일

#### 디렉터리와 링크

#### 하드 링크

#### 심벌릭 링크

#### 특수 파일

#### 파일 시스템과 네임스페이스


### 1.4.2 프로세스


---------------------------------------------------------

## <b id = "f1"><sup>1 </sup></b>레지스터(Register)[ ↩](#a1)

- CPU가 프로세스를 실행하기 위해서는 프로세스를 CPU에 적재시켜야 할 것이다. 그리고 이렇게 흩어져 있는 명령어 집합(Instruction Set)과 데이터들을 적절하게 집어내어 읽고 저장하기 위해서는 여러 가지 저장 공간이 필요하다. 또한 CPU가 재빨리 읽고 쓰기를 해야 하는 데이터들이므로 CPU 내부에 존재하는 메모리를 사용한다. 이러한 공간을 **레지스터(Register)** 라고 한다.

- 레지스터는 그 목적에 따라서 **4개의 종류**로 나누어진다.
 
  - 범용 레지스터 (General-Purpose Register)
  - 세그먼트 레지스터 (Segment Register)
  - 상태 플래그 레지스터 (Program Status and Control Register)
  - 명령 포인터 레지스터 (Instruction Pointer Register)

<br>
<p align = "center">
<img src = "https://user-images.githubusercontent.com/39554623/58073975-fed77500-7bde-11e9-940c-60b5327531bf.png">
</p>
<br>

### 범용 레지스터 (General-Purpose Register)

> 범용 레지스터는 **프로그래머가 임의로 조작할 수 있게 허용되어 있는 레지스터** 이다.
  
- 일종의 4개의 32bit 변수라고 생각하면 된다.

- 예전의 16bit 시절에서는 각 레지스터를 `AX, BX, CX, DX ..` 등으로 불렀지만 32bit 시스템으로 전환되면서 **E (Extended)** 가 앞에 붙어 `EAX, EBX, ECX, EDX ..` 등으로 불린다.

- 상위 8 비트는 High라서 `H` 가 붙고, 하위 8 비트는 Low라서 `L` 이 붙는다고 생각하면 외우기 쉽다.

<br>
<p align = "center">
<img src = "https://user-images.githubusercontent.com/39554623/58071480-d13afd80-7bd7-11e9-9f04-c2e62939d9f0.png">
</p>
<br>

> EAX (Extended Accumulator Register)

산술연산 명령에서 상수/변수 값을 저장하거나 함수의 리턴 값이 저장되는 용도로도 사용된다.

> EBX (Extended Base Register)

EBX는 DS 세그먼트에 대한 포인터를 주로 저장하고 ESI나 EDI와 결합하여 인덱스에 사용된다. EBX는 메모리 주소 지정을 확장하기 위해 인덱스로 사용될 수 있는 유일한 범용 레지스터이다.

> ECX (Extended Counter Register)

 반복 명령어 사용 시 반복 카운터로 사용된다. ECX 레지스터에 반복할 횟수를 지정해 놓고 반복 작업을 수행하게 된다.

> EDX (Extended Data Register)

 데이터 레지스터이다. 입, 출력 포인터 값을 저장할 때 사용한다. 

> ESI (Extended Source Index)

 데이터 복사나 조작 시 Source Data의 주소가 저장된다. ESI 레지스터가 가리키는 주소의 데이터를 EDI 레지스터가 가리키는 주소로 복사하는 용도로 많이 사용된다.

> EDI (Extended Destination Index)

 복사 작업 시 Destination의 주소가 저장된다. 주로 ESI 레지스터가 가리키는 주소의 데이터가 복사된다.

> ESP (Extended Stack Pointer)

 하나의 스택 프레임의 끝 지점 주소가 저장된다. PUSH, POP 명령어에 따라서 ESP의값이 4Byte씩 변한다.

> EBP (Extended Base Pointer)

 하나의 스택 프레임의 시작 지점 주소가 저장된다. 현재 사용되는 스택 프레임이 소멸되지 않는 동안 EBP 의 값은 변하지 않는다. 현재의 스택 프레임이 소멸되면 이전에 사용되던 스택 프레임을 가리키게 된다.

<br>

### 세그먼트 레지스터 (Segment Register)

- 세그먼트 레지스터는 총 6개(CS, SS, DS, ES, FS, GS)이고 각 크기는 16비트이다.

- 각 세그먼트 레지스터가 가리키는 세그먼트 디스크립터와 가상메모리가 조합되어 선형주소가 되며, 페이징 기법에 의해서 선형 주소가 최종적으로 물리주소로 변환됩니다.

  - 만약 OS에서 페이징을 사용하지 않는다면 선형주소는 그대로 물리주소가 됩니다.

> CS(Code Segment)

 코드 영역의 시작 주소를 저장한다.

> DS(Data Segment)

 데이터 영역의 시작 주소를 저장한다.

> ES(Extra Segment)

 비디오 영역의 시작 주소를 저장한다.

> FS

 기타 영역의 시작 주소를 저장한다.

> SS(Stack Segment)

 스택 영역의 시작 주소를 저장한다.

<br>

 ### 명령 포인터 레지스터 (Instruction Pointer Register)

 > EIP (Extended Instruction Pointer)

 - 다음에 실행해야 할 명령어가 존재하는 메모리 주소가 저장된다.

 - 현재 명령어를 실행 완료한 후에 EIP 레지스터에 저장되어 있는 주소에 위치한 명령어를 실행하게 된다. 실행 전 EIP 레지스터에는 다음 실행해야 할 명령어가 존재하는 주소의 값이 저장된다.

<br>

## <b id = "f2"><sup>2 </sup></b>[라이브러리 API, ABI 뜻의 비교](https://eine.tistory.com/entry/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-API-ABI-%EB%9C%BB-%EB%B9%84%EA%B5%90-%EC%A0%95%EB%A6%AC) [ ↩](#a2)

보통 외부 컴포넌트의 경우 라이브러리 형태로 제공받는 경우가 많아서 라이브러리와 API의 뜻을 햇갈려하는 경우가 많다.

- **라이브러리**는 이러한 **컴포넌트 자체**를 뜻하고

- **API**는 이 **컴포넌트를 활용하는 규약**이라고 보면 된다.
