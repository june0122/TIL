# 코루틴 간단 요약

### 코루틴은 경량 스레드

- 코루틴은 스레드 안에서 실행
    - 스레드 하나에 많은 코루틴이 있을 수 있지만 한 시점에 하나의 코루틴만 실행된다.
    - 코틀린은 **고정된 크기의 스레드 풀**을 사용하고 코루틴들을 **스레드들에 배포**하기 때문에 실행 시간이 매우 적게 증가한다.
    - 코루틴이 특정 스레드 안에서 실행되더라도 스레드와 묶이지 않는다. 코루틴의 일부를 특정 스레드에서 실행하고, 실행을 중지한 다음 나중에 다른 스레드에서 계속 실행하는 것이 가능하다. 코틀린이 실행 가능한 스레드로 코루틴을 이동시키기 때문이다.
    - 스레드는 한 번에 하나의 코루틴만 실행할 수 있기 때문에 프레임워크가 필요에 따라 코루틴을 스레드들 사이에 옮기는 역할을 한다. 코틀린은 개발자가 코루틴을 실행할 스레드를 지정하거나 해당 스레드로 제한할지 여부를 지정할 수 있을만큼 유연하다.

### 동시성과 병렬성

- 동시성은 두 개 이상의 알고리즘의 실행 시간이 겹칠 때 발생한다.
    - 중첩이 발생하려면 두 개 이상의 실행 스레드가 필요하다.
    - 이런 스레드들이 단일 코어에서 실행되면 병렬이 아니라 동시에 실행되는데, 단일 코어가 서로 다른 스레드의 인스트럭션을 교차 배치해서, 스레드들의 실행을 효율적으로 겹쳐서 실행한다.
- 병렬은 두 개의 알고리즘이 정확히 같은 시점에 실행될 때 발생한다.
    - 이것이 가능하려면 2개 이상의 코어와 2개 이상의 스레드가 있어야 각 코어가 동시에 스레드의 인스트럭션을 실행할 수 있다.
    - 병렬은 동시성을 의미하지만 동시성은 병렬성이 없어도 발생할 수 있다.

### 동시성이 어려운 이유

- **레이스 컨디션(경쟁 상태)** : 둘 이상의 프로세스나 스레드가 공유자원에 동시에 접근할 때 접근하는 순서에 따라 비정상적인 결과가 발생하는 조건/상황
    - 코드를 동시성으로 작성했지만 순차적 코드처럼 동작할 것이라 예상할 때 발생
    - ex) DB에서 데이터를 가져오고 웹 서비스를 호출하는 기능을 동시에 수행하는 코드를 작성하였고, 이 두 작업이 모두 끝나면 약간의 연산을 수행한다고 가정. DB의 작업이 더 빠를 것이라 예상하고 웹 서비스 작업이 끝나자마자 DB 작업 결과에 접근할 경우 DB 작업이 웹 서비스 호출보다 오래 걸릴 때마다 앱이 중단되거나 일관되지 않은 상태에 빠진다.
- **원자성 위반**
    - 원자성 작업(atomic operations)이란 작업이 사용하는 데이터를 간섭 없이 접근할 수 있음을 말한다.
    - 단일 스레드 애플리케이션에서는 모든 코드가 순차적으로 실행되기 때문에 모든 작업이 원자(atomic)일 것이다. 스레드가 하나만 실행되므로 간섭이 있을 수 없다.
    - 원자성은 객체의 상태가 동시에 수정될 수 있을 때 필요하며 그 상태의 수정이 겹치지 않도록 보장해야 한다.
- **데드락(교착 상태)** : 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태
- **라이브락** : 라이브락은 두 스레드가 락의 해제와 획득을 무한 반복하는 상태이다. 라이브락은 데드락을 피하려는 의도에서 수정한 코드가 불완전할 때 발생하곤 한다.

### 코틀린 동시성 관련 개념과 용어

- **[일시 중단 함수 (suspend function)](https://june0122.tistory.com/17)**

```kotlin
suspend fun greetAfter(name: String, delayMillis: Long) {
	delay(delayMillis)
	println("Hello, $name")
}
```

`greetAfter()` 의 실행은 `delay()` 가 호출될 때 일시 중단된다. `delay()` 자체가 일시 중단 함수이며, 주어진 시간 동안 실행을  일시 중단한다. `delay()` 가 완료되면 `greetAfter()` 가 실행을 정상적으로 다시 시작한다. `greetAfter()` 가 일시 중지된 동안 실행 스레드가 다른 연산을 수행하는 데 사용될 수 있다.

- **코루틴 디스패처** : 코루틴을 시작하거나 재개할 스레드를 결정하기 위해 코루틴 디스패처가 사용된다.
- **코루틴 빌더** : 일시 중단 람다를 받아 그것을 실행시키는 코루틴을 생성하는 함수.
    - `async()` : 결과가 예상되는 코루틴을 시작하는데 사용하며, 결과 또는 예외를 포함하는 `Deffered<T>` 를 반환한다. `[async` 는 `await` 를 호출할 때 누적된 예외를 던진다.](https://june0122.tistory.com/20)
    - `launch()` : 결과를 반환하지 않는 코루틴을 시작한다. 자체 혹은 자식 코루틴의 실행을 취소하기 위해 사용할 수 있는 `Job` 을 반환한다.
    - `runBlocking()` : 블로킹 코드를 일시 중지 가능한 코드로 연결하기 위해 사용된다. 코루틴의 실행이 끝날 때까지 현재 스레드를 차단한다.

### 참고: 세마포어 vs 뮤텍스

- **임계 구역(Critical Section)** : 여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분
- **세마포어**는 공유 자원에 세마포어의 변수만큼의 프로세스(또는 쓰레드)가 접근할 수 있습니다.
    - 현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있습니다.
- 반면에 **뮤텍스**는 오직 1개만의 프로세스(또는 쓰레드)만 접근할 수 있습니다.
    - 하지만 뮤텍스는 락(lock)을 획득한 프로세스가 반드시 그 락을 해제해야 합니다.

### 코루틴의 취소, Structured Concurrency, SupervisorJob

- https://june0122.tistory.com/20