# 2장 코틀린 기초

## 2.1 기본 요소: 함수와 변수

```kotlin
fun main(args: Array<String>) {
    println("Hello, world!")
}
```

- 함수를 선언할 때 `fun` 키워드를 사용<sup> 수많은 함수, 즐거움들을 만들어보자</sup>
  
- 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다.
  
  - 변수 선언 시에도 같은 방식으로 타입을 지정한다.

- 함수를 최상위 수준에 정의할 수 있다.
  
  - (자바와 달리) 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.

- 배열도 일반 클래스와 마찬가지다. 코틀린에는 자바와 달리 배열 처리를 위한 문법이 존재하지 않는다.

- `system.out.println` 대신에 `println` 이라고 쓴다.

  - 코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용하도록 감싼 래퍼<sup> wrapper</sup>를 제공한다.
  - `println`도 그런 함수 중 하나이다.

- 최신 프로그래밍 언어 경향과 마찬가지로 줄 끝에 세미콜론 (`;`)을 붙이지 않아도 된다.

### 2.1.2 함수

> #### 코틀린 함수의 기본 구조

<br>
<p align = 'center'>
<img width = '700', src = 'https://user-images.githubusercontent.com/39554623/59262188-b2c99e80-8c79-11e9-8914-297283b538b3.png'>
</p>
<br>

- 위는 코틀린 함수의 기본 구조이다.

- **코틀린 if**는 (값을 만들어내지 못하는) **문장이 아니고 결과를 만드는 식**<sup> expression</sup>이라는 점이 흥미로운 부분.

<br>

> #### 문(statement)과 식(expression)의 구분

- **코틀린 if는 식이지 문이 아니다.**

- 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면, 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 
존재하며 아무런 값을 만들어내지 않는다는 차이가 있다.

- 자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 **루프를 제외한 대부분의 제어 구조가 식이다.**

- 반면 대입문은 자바에서는 식이었으나 코틀린에선는 문이 됐다.

  - 그로 인해 자바와 달리 대입식과 비교식을 잘못 바꿔 써서 버그가 생기는 경우가 없다.

<br>

> #### 식이 본문인 함수

```kotlin
fun main(args: Array<String>) {
    println("Hello, world!")
}
```

- 위의 식과 같이 식 하나로만 이뤄져 있는 경우 더 간결하게 표현할 수도 있다.

- **중괄호를 없애고 return을 제거하면서 등호 `=` 를 식 앞에 붙이면 된다.**

```kotlin
fun max(a : Int, b : Int) : Int = if (a > b) a else b
```

- 여기서 반환 타입을 생력하면 max 함수를 더 간략하게 만들 수 있다.

```kotlin
fun max(a : Int, b : Int) = if (a > b) a else b
```

- 코틀린은 정적 타입 지정 언어이지만, **식이 본문인 함수의 경우** 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다.

  - 컴파일러가 프로그래머 대신 프로그램의 구성 요소의 타입을 정해주는 기능을 **타입 추론<sup> type inference</sup>** 이라 한다.

- **식이 본문인 함수의 반환 타입만 생략이 가능하다는 점에 유의한다.**

### 2.1.3 변수

#### 변경 가능한 변수와 불가능한 변수

> `val` (값을 뜻하는 value에서 따옴)

- 변경 불가능한<sup> immutable</sup> 참조

- 자바의 `final 변수`에 해당

> `var` (변수를 뜻하는 variable에서 따옴)

- 변경 가능한<sup> mutable</sup> 참조

- 자바의 `일반 변수`에 해당


- 기본적으로 모든 변수를 `val` 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 `var`로 변경하라.

### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 탬플릿 `$`

> 문자열 탬플릿 사용 예제

```kotlin
fun main(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "Kotlin"
    println("Hello, $name!")
}
```
- 문자열 탬플릿<sup> string template</sup> 기능은 변수를 문자열 리터럴 안에서 사용할 수 있도록 해주는 기능을 가지고 있다.

  - 자바의 문자열 접합 연산 `"Hello, " + name + "!"` 과 동일한 기능을 하지만 좀 더 간결하고 효율적이다.

  - `$` 문자를 문자열에 넣고 싶으면 `print("\$x")` 와 같이 `\`를 사용해 `$`를 이스케이프<sup> escape</sup> 시켜야 한다.
  
- 문자열 템플릿 안에는 복잡한 식도 중괄호`{ }`로 둘러싸서 안에 넣을 수 있다.

  - 중괄호로 둘러싼 식 안에서 큰 따옴표를 사용할 수도 있다.

    ```kotlin
    fun main(args: Array<String>) {
        println("Hello, ${if (args.size > 0) args[0] else "someone"}!")
    }
    ```

## 2.2 클래스와 프로퍼티

### 2.2.1 프로퍼티

> **프로퍼티<sup> property</sup>** : 필드와 접근자를 한데 묶어 칭하는 단어

- 자바에서는 필드와 접근자를 한데 묶어 프로퍼티라 부르며, 프로퍼티 개념을 활용하는 프레임워크가 많다.

- 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며, 코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 완전히 대신한다.

- 클래스에서 프로퍼티를 선언할 때는 변수를 선언할 때와 마찬가지로 `val` 이나 `var`을 사용한다.

```kotlin
class Person(
    val name: String,  // 읽기 전용 프로퍼티로, 코틀린은 (비공개) 필드와 필드를 읽는 단순한 (공개) 게터를 만들어낸다.
    var isMarried: Boolean  // 쓸 수 있는 프로퍼티로, (비공개) 필드, (공개) 게터, (공개) 세터를 만들어낸다.
)
```

### 2.2.2 커스텀 접근자

### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지

- 코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있다.

- 코틀린에서느 디스크상의 **어느 디렉터리에 소스코드 파일을 위치시키든 관계없다.**

  - 원하는 대로 소스코드를 구성할 수 있다.

- 하지만 대부분의 경우 자바와 같이 패키지별로 디렉터리를 구성하는 편이 낫다.

  - 특히 자바와 코틀린을 함께 사용하는 프로젝트에서는 자바의 방식을 따르는게 중요하다.

  - 자바의 방식을 따르지 않으면 자바 클래스를 코틀린 클래스로 마이그레이션할 때 문제가 생길 수도 있다.


## 2.3 선택 표현과 처리: enum과 when

### 2.3.1 enum 클래스 정의

```kotlin
enum class Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}
```

- 코틀린에서 `enum`은 **소프트 키워드<sup> soft keyword</sup>** 라 부르는 존재다.

  - `enum`은 `class` 앞에 있을 때는 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있다.

- 반면 `class`는 키워드다.

  - 따라서 `class`라는 이름을 사용할 수 없으므로 클래스를 표현하는 변수 등을 정의할 때는 clazz, aClass 같은 다른 이름을 사용해야 한다. 

<br>

> #### `enum` 클래스 안에도 프로퍼티나 메소드를 정의할 수 있다.

```kotlin
enum class Color(
    val r: Int, val g: Int, val b: Int  // 상수의 프로퍼티 정의
) {
    // 각 상수 생성 시 프로퍼티 값 지정
    RED(255, 0, 0), ORANGE(255, 165, 0),
    YELLOW(255, 255, 0), GREEN(0, 255, 0), BLUE(0, 0, 255),
    INDIGO(75, 0, 130), VIOLET(238, 130, 238);  // 여기에 반드시 세미콜론 사용해야 한다.

    fun rgb() = (r * 256 + g) * 256 + b  // enum 클래스 안에서 메소드 정의
}

>>> println(Color.BLUE.rgb())
255

```

- enum에서도 일반적인 클래스와 마찬가지로 생성자와 프로퍼티를 선언한다.

  - 각 enum 상수를 정의할 때는 그 상수에 해당하는 프로퍼티 값을 지정해야만 한다.

- 코틀린에서 유일하게 세미콜론 `;` 이 필수인 부분이 enum 클래스 안에 메소드를 정의하는 경우이다.

  - **enum 상수 목록과 메소드 정의 사이에 반드시 세미콜론을 넣어야 한다.**

### 2.3.2 `when`으로 enum 클래스 다루기

- 자바의 `switch`에 해당하는 코틀린 구성 요소는 `when`이다

  - `if` 와 마찬가지로 `when`도 값을 만들어내는 식이므로, 식이 본문인 함수에 바로 `when`을 사용할 수 있다.

```kotlin
enum class Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}

fun getMnemonic(color: Color) =
    when (color) {
        Color.RED -> "Richard"
        Color.ORANGE -> "Of"
        Color.YELLOW -> "York"
        Color.GREEN -> "Gave"
        Color.BLUE -> "Battle"
        Color.INDIGO -> "In"
        Color.VIOLET -> "Vain"
    }

fun main() {
    println(getMnemonic(Color.BLUE))
}
```

- 자바와 달리 각 분기의 끝에 `break`를 넣지 않아도 된다.
  
- 한 분기 안에 여러 값을 매치 패턴으로 사용할 수도 있다. 그럴 경우 값 사이를 콤마 `,`로 분리한다.

### 2.3.3 `when`과 임의의 객체를 함께 사용

> 코틀린의 `when`은 자바의 `switch` 보다 훨씬 강력하다.

- 분기 조건에 상수 (enum 상수나 숫자 리터럴)만을 사용할 수 있는 자바 `switch`와 달리 **코틀린 `when`의 분기 조건은 임의의 객체를 허용**한다.

### 2.3.4 인자 없는 `when` 사용

### 2.3.5 스마트 캐스트: 타입 검사와 타입 캐스트를 조합

