## 들어가기 전에

- 자바를 대신할 언어의 처음이자 가장 중요한 요구 사항 : **정적 타입 지정(Static Typing)**

- DSL(Domain-specific Language, 도메인<sup> 영역</sup> 특화 언어)  <-->  GPL(General-purpose language, 범용 언어)

# 1장. 코틀린이란 무엇이며, 왜 필요한가?

> 코틀린<sup> Kotlin</sup> : 자바 플랫폼에서 돌아가는 새로운 프로그래밍 언어

- 자바 코드와의 상호운용성을 중시
- 자바가 사용 중인 곳이라면 대부분 코틀린 활용 가능
- 서버 개발, 안드로이드 앱 개발 등의 분야에서 주로 사용

## 1.1 코틀린 맛보기

```kotlin
data class Person(val name: String,
                  val age: Int? = null)

fun main(args: Array<String>) {
    val persons = listOf(Person("Alice"),
                         Person("Bob", age = 29))

    val oldest = persons.maxBy { it.age ?: 0 }
    println("The oldest is: $oldest")
}
```

- `?:` (엘비스 연산자<sup> Elvis Operator</sup>) : 프로퍼티가 null인 경우 0을 반환하고, 그렇지 않은 경우 해당 프로퍼티의 값을 반환

## 1.2 코틀린의 주요 특성

### 1.2.1 대상 플랫폼: 서버, 안드로이드 등 자바가 실행되는 모든 곳

- 코틀린의 주목적 : 자바가 사용되고 있는 모든 용도에 적합하면서도 더 간결하고 생산적이며 안전한 대체 언어를 제공

### 1.2.2 정적 타입<sup>statically typed</sup> 지정 언어

- 모든 프로그램의 구성 요소의 타입을 **컴파일 시점**에 알 수 있다.
- 프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증해준다.

  - `반의어` : **동적 타입**<sup> dynamically typed</sup>
    
    - 타입과 관계없이 모든 값을 변수에 넣을 수 있고, 메소드나 필드 접근에 대한 검증이 **실행 시점**에 일어난다.
    - 그에 따라 코드가 더 짧아지고 데이터 구조를 더 유연하게 생성하고 사용할 수 있다.
    - 하지만 반대로 이름을 잘못 입력하는 등의 실수를 컴파일 시에 걸러내지 못한다.

- 자바와 달리 코틀린에서는 모든 변수의 타입을 프로그래머가 직접 명시할 필요가 없다.

  - 대부분 코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추할 수 있기 때문에 **타입 선언 생략 가능**.

> 타입 추론 <sup> type inference</sup> : 컴파일러가 문맥을 고려해 변수 타입을 결정하는 기능

- 변수를 정의하면서 자동으로 알맞게 초기화

```kotlin
var x = 1       // 정수 값으로 초기화
```

#### 정적 타입 지정의 장점

- **성능** : 실행 시점에 어떤 메소드를 호출할지 알아내는 과정이 필요 없으므로 메소드 호출이 더 빠름.
- **신뢰성** : 컴파일러가 프로그램의 정확성을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 더 적어짐.
- **유지 보수성** : 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있으므로 처음 보는 코드를 다룰 때도 더 쉽다.
- **도구 지원** : 정적 타입 지정을 활용하면 더 안전하게 **리팩토링**<sup> refactoring</sup> 할 수 있으며, 도구는 더 정확한 코드 완성 기능을 제공할 수 있고, IDE의 다른 지원 기능도 더 잘 만들 수 있다.


#### 코틀린의 새로운 점

- 널이 될 수 있는 타입<sup> nullable type</sup>

- 함수 타입<sup> function type</sup> 


### 1.2.3 함수형 프로그래밍과 객체지향 프로그래밍

#### 함수형 프로그래밍의 핵심 개념

- 일급 시민인<sup> fisrt-class</sup> 함수
- 불변성<sup>immutability</sup>
- 부수 효과<sup> side effect</sup> 없음

#### 함수형 스타일의 유익성

1. 간결성

2. 다중 스레드를 사용해도 안전<sup> safe multithreading</sup>

3. 테스트하기 쉽다.

#### 코틀린은 함수형 스타일의 프로그래밍을 지원하지만 그것을 강제하지는 않는다.

- 명령형 방식이 더 적합한 경우라면 직접 변경 가능한 데이터와 부수 효과를 활용하는 함수 사용 가능
- 당연히 인터페이스와 클래스 계층 구조를 바탕으로 하는 프레임워크도 자바를 사용할 때와 마찬가지로 쉽게 사용 가능

## 1.3 코틀린 응용

### 1.3.2 코틀린 안드로이드 프로그래밍

- 안드로이드 앱의 '프로세스가 중단됨' 대화상자
  - 애플리케이션에서 처리되지 않은 예외<sup> 주로 NullPointerExeption</sup>가 발생한 경우에 표시된다.
  - 코틀린 타입 시스템은 null 값을 정확히 추적하며 널 포인터로 인해 생기는 문제를 줄여준다.

- 코틀린은 자바 6와 완전히 호환된다.

- 코틀린을 사용하더라도 성능 측면에서 아무 손해가 없다.
  
  - 코틀린 컴파일러가 생성한 바이트코드는 일반적인 자바 코드와 똑같이 효율적으로 실행된다.
  - 코틀린의 런타임 시스템은 상당히 작기 때문에 컴파일 후 패키징한 애플리케이션 크기도 그리 많이 늘어나지 않는다.
  - 대부분의 코틀린 표준 라이브러리 함수는 인자로 받은 람다 함수를 인라이닝<sup> inlining</sup>한다.
    
    - 따라서 람다를 사용해도 새로운 객체가 만들어지지 않으므로 객체 증가로 인해 가비지 컬렉션이 늘어나서 프로그램이 자주 멈추는 일도 없다.

## 1.4 코틀린 철학

> ### 코틀린은 자바와의 상호운용성에 초점을 맞춘 실용적이고 간결하며 안전한 언어이다.

### 1.4.1 실용성

### 1.4.2 간결성

### 1.4.3 안정성

> **프로그래밍 언어가 안전하다**

- 프로그램에서 발생할 수 있는 오류 중에서 일부 유형의 오류를 프로그램 설계가 원천적으로 방지해준다는 뜻

### 1.4.4 상호운용성

- 기존 자바 라이브러리를 그대로 사용할 수 있다.
  
- 자바 메소드를 호출하거나 자바 클래스를 상속(확장)하거나 인터페이스를 구현하거나 자바 애노테이션을 코틀린 코드에 적용하는 등의 일이 모두 가능하다.


## 1.5 코틀린 도구 사용

- 자바와 마찬가지로 코틀린도 컴파일 언어이다. 따라서 코틀린 코드를 실행하기 전에 먼저 코드를 컴파일해야만 한다.

### 1.5.1 코틀린 코드 컴파일

- 코틀린 소스코드를 저장할 때는 보통 `.kt`라는 확장자를 파일에 붙인다.
- 코틀린 컴파일러는 자바 컴파일러가 자바 소스코드를 컴파일할 때와 마찬가지로 코틀린 소스코드를 분석해서 `.class` 파일을 만들어낸다.
- 만들어진 `.class` 파일은 개발 중인 애플리케이션의 유형에 맞는 표준 패키징 과정을 거쳐 실행될 수 있다.
  - 가장 간단한 방식은 커맨드라인에서 kotlin 명령을 통해 코틀린 코드를 컴파일 한 다음 java 명령으로 그 코드를 실행

    ```
    kotlinc <소스파일 또는 디렉터리> -include-runtime -d <jar 이름>
    java -jar <jar 이름>
    ```

<br>

> ### 코틀린 빌드 과정

<br>
<p align = 'center'>
<img src = 'https://user-images.githubusercontent.com/39554623/59185723-1c7b7700-8bac-11e9-93d9-f995ce12544f.png'>
</p>
<br>

- 코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리에 의존한다.

  - 코틀린으로 컴파일한 애플리케이션을 배포할 때는 **런타임 라이브러리도 함께 배포**해야 한다.
  
- 실제로 개발을 진행한다면 프로젝트를 컴파일하기 위해 메이븐<sup> Maven</sup>, 그레이들<sup> Gradle</sup>, 앤트<sup> Ant</sup> 등의 **빌드 시스템**을 사용할 것이다.

  - 메이븐과 그레이들은 애플리케이션을 패키지할 때 알아서 코틀린 런타임을 포함시켜준다.
