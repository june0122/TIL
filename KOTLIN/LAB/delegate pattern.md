# Delegate Pattern

소프트웨어 엔지니어링에서 <b>delegate pattern<small>(위임 패턴)</small></b>은 객체 합성이 상속과 동일하게 코드 재사용을 할 수 있도록 하는 객체 지향 디자인 패턴이다.

## 상속<small>(inheritance)</small> vs 합성<small>(composition)</small>

> 객체지향 시스템에서 기능의 재사용을 위해 구사하는 가장 대표적인 기법은 클래스 상속, 그리고 객체 합성<small>(object composition)</small>이다.

### 클래스 상속
- 서브클래싱, 즉 다른 부모 클래스에서 상속받아 한 클래스의 구현을 정의하는 것.
- 서브클래싱에 의한 재사용을 화이트박스 재사용<small>(white-box reuse)</small>이라고 한다.
  - '화이트박스'는 내부를 볼 수 있다는 의미에서 나온 말로, 상속을 받으면 부모 클래스의 내부가 서브클래스에 공개되기 때문에 화이트박스인 셈이다.

### 객체 합성
- 클래스 상속에 대한 대안으로 다른 객체를 여러 개 붙여서 새로운 기능 혹은 객체를 구성하는 것이다.
  - 즉, 객체 또는 데이터 유형을 더 복잡한 유형으로 결합하는 방법
- 객체를 합성하려면, 합성에 들어가는 객체들의 인터페이스를 명확하게 정의해 두어야 한다.
- 이런 스타일의 재사용을 블랙박스 재사용<small>(black-box reuse)</small>이라고 한다.
  - 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문.

상속과 합성은 서로 장단점을 가지고 있다.

#### 클래스 상속의 장단점

장점
- 컴파일 시점에 정적으로 정의되고 프로그래밍 언어가 직접 지원하므로 그대로 사용하면 된다.
- 클래스 상속으로 부모 클래스의 구현을 쉽게 수정할 수도 있는데, 서브클래스는 모든 연산이 아닌 일부만 재정의할 수도 있다.

단점
- 런타임에 상속받은 부모 클래스의 구현을 변경할 수 없다.
  - 상속은 컴파일 시점에 결정되는 사항이기 때문.
- 부모 클래스는 서브클래스의 물리적 표현의 최소 부분만을 정의하기 때문에 서브클래스는 부모 클래스가 정의한 물리적 표현들을 전부 또는 일부 상속받는다는 점.
  - 상속은 부모 클래스의 구현이 서브클래스에 다 드러나는 것이기 때문에 상속은 캡슐화를 파괴한다고 보는 시각도 있다.
  - 서브클래스는 부모 클래스의 구현에 종속될 수밖에 없으므로, 부모 클래스 구현에 변경이 생기면 서브클래스도 변경해야 한다.

이 구현의 종속성이 걸림돌로 작용하면서, 서브클래스를 재사용하려고 할 때 문제가 발생한다. 상속한 구현이 새로운 문제에 맞지 않을 때, 부모 클래스를 재작성해야 하거나 다른 것으로 대체하는 일이 생기게 된다. 이런 종속성은 유연성과 재사용성을 떨어뜨린다.
  - 이를 해결하는 방법 한 가지는 추상 클래스에서만 상속 받는 것이다. 추상 클래스에는 구현이 거의 없거나 아예 없기 때문이다. 이미 추상 클래스를 상속했다는 것은 구현이 아닌 인터페이스를 상속한 것이므로 구현 자체는 서브클래스가 정의한다. 구현이 변경되면 서브클래스만 변경하면 되고 상위 추상 클래스는 고려할 필요가 없다.

#### 객체 합성

객체 합성은 한 객체가 다른 객체에 대한 참조자를 얻는 방식으로 런타임에 동적으로 정의된다. 합성은 객체가 다른 객체의 인터페이스만을 바라보게 하기 때문에, 인터페이스 정의에 더 많은 주의를 기울여야 한다. 객체는 인터페이스에서만 접근하므로 캡슐화를 유지할 수 있다. 동일한 타입을 갖는다면 다른 객체로 런타임에 대체가 가능하다. 객체는 인터페이스에 맞춰 구현되므로 구현 사이의 종속성은 확실히 줄어든다.

객체 합성은 시스템 설계에 또 다른 영향을 끼친다. 클래스 상속보다 객체 합성을 더 선호하는 이유는 각 클래스의 캡슐화를 유지할 수 있고, 각 클래스의 한 가지 작업에 집중할 수 있기 때문이다. 객체 합성으로 설계되면 클래스의 수는 적어지고 객체의 수는 좀더 많아질 수 있지만, 시스템의 행동은 클래스에 정의된 정적인 내용보다는 런타임에 드러나는 객체 합성에 의한 상호 관련성에 따라 달라질 수 있다.

> ### 클래스 상속보다는 객체 합성을 선호하라<small>(Favor object composition over class inheritance.)</small>. 

결론적으로 재상용을 위해서 새로운 구성요소를 생성할 필요 없이 필요한 기존의 구성요소를 조립해서 모든 새로운 기능을 얻어올 수 있다. 그러나 가능한 구성요소의 집합이 실제로 사용할 수 있을 만큼 충분하지 않기 때문에, 기존 구성요소의 조합을 통한 재사용만으로 목적을 달성할 수 있는 경우는 드물다. 상속에 의한 재사용은 기존 클래스들을 조합해서 새로운 구성요소를 쉽게 만들 수 있도록 해 준다. 그러므로 상속과 객체 합성은 적절히 조합되어야만 완벽히 재사용이 가능하다.

## 위임<small>(delegation)</small>

위임은 합성을 상속만큼 강력하게 만드는 방법이다.

## References
- &lt;Gof의 디자인 패턴&gt; 한국어판 : 상속 대 합성<small>(49p)</small>, 위임<small>(51p)</small>
- wikipedia : [Delegation pattern](https://en.wikipedia.org/wiki/Delegation_pattern)
- [잘못 알려진 디자인 패턴의 두번째 원칙](https://architecture101.blog/2009/02/18/misconception_of_gof_dp/)
- [favor object composition over class inheritance의 두 가지 해석](http://occamsrazr.net/tt/entry/favor-object-composition-over-class-inheritance%EC%9D%98-%EB%91%90-%EA%B0%80%EC%A7%80-%ED%95%B4%EC%84%9D)