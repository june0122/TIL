# Synchronous, Asynchronous / Blocking, Non-Blocking

## 개요

동기, 비동기의 원래 의미는 통신에서

- 상대방의 일정 신호에 의해서 다음 동작이 이루어지면 **동기**

- 상대방의 상태와 관계없이 일방적으로 동작하면 **비동기**

이와 비슷한 개념으로 일반 소프트웨어에서는

- 어떤 루틴을 완전히 끝내고 제어를 반납하면 **동기식**

- 동작이 안 끝났어도 일단 제어권을 반납한 후 자신의 할 일을 계속하면 **비동기식**

예를 들어 siren 소리를 낼때

```
play_sound("siren.wav","동기");
a = b + c;
```

동기식은 사이렌 소리가 다 끝난후 `a = b + c` 가 실행되고

```
play_sound("siren.wav","비동기");
a = b + c;
```

비동기식은 `a = b + c` 이하 프로그램을 계속 수행하면서 siren소리가 난다.

file 조작에서도 이와 마찬가지이다.

- file조작이 완전히 끝난후 다음 동작이 이루어지는 방식이 동기식,

- 다음 code를 진행하면서 file조작을 하면 비동기식입니다

<br>

### 동기(Synchronous)와 비동기(Asynchronous)

- 호출되는 함수의 **작업 완료 여부**를 누가 신경쓰느냐가 관심사

- **작업 순서**가 구분 기준

- 동기 / 비동기는 **행위에 대한 이야기**이다. (기술적으로 구분되지 않으며, **추상적으로 구분**한다.)

#### 동기(Synchronous)

> 동기식 처리 모델은 우리가 만드는 대부분의 프로세스의 로직이며, 특히 Pipeline 을 준수하는 Working Process 에서 매우 훌륭한 모델

- 요청과 결과가 동시에 일어난다.

- 호출하는 함수가 호출되는 함수의 작업 완료 후 리턴을 기다리거나, 또는 호출되는 함수로부터 바로 리턴 받더라도 **작업 완료 여부를 호출하는 함수 스스로 계속 확인하며 신경 씀.**

    - 호출되는 함수의 작업 완료를 **호출'한' 함수가 신경쓰면** 동기식이다.

- A라는 행위와 B라는 행위가 순차적으로 작동한다면 동기라고 한다.

  - 동기적 행동에는 하나가 더 있다. A라는 행위가 별개의 것이 아니라, B라는 행위를 **관찰**하는 행위라면 이것이 동시에 일어나더라도 동기이다. 기술적으로 말해서 A라는 쓰레드와 B라는 쓰레드가 따로 돌아 간다고해도, 어떤 하나의 행위가 다른 행위에 밀착되어 있다면 두 행위가 다른 쓰레드에서 벌어지더라도 동기라는 이야기다. 

#### 비동기(Asynchronous)

> 비동기식 처리 모델이 이득을 보는 경우는 각 작업이 분리될 수 있으며, **Latency 가 큰 경우**이다. 예를들어 각 클라이언트 또는 작업 별로 Latency 가 발생하는 네트워크 처리나 File I/O 등이 훌륭한 적용 예시이다

- 요청과 그 결과가 동시에 일어나지 않는다.

- A라는 행위와 B라는 행위가 동시에 실행되고 있으면(순차적으로 작동하지 않는다면) 비동기식이다.

  - 여기서 제약이 하나 있는데, **A와 B 행위 사이에는 인과관계가 있어야 한다.** 즉 웹서버를 예로 들어 멀티 쓰레드로 각각 A와 B가 다른 클라이언트와 작업할 때 둘은 동시에 작업하고 있지만, 둘의 인과관계는 없다. 이럴 땐 비동기라고 볼 수 없다.

- 호출되는 함수에게 callback을 전달해서, 호출되는 함수의 작업이 완료되면 호출되는 함수가 전달받은 callback을 실행하고, **호출하는 함수는 작업 완료 여부를 신경쓰지 않음.**

    - 호출되는 함수의 작업 완료를 **호출'된' 함수가 신경쓰면** 비동기식이다.

<br>

### 블로킹(Blocking)과 논블로킹(Non-Blocking)

- 호출되는 함수가 **바로 리턴하느냐 마느냐**가 관심사

- **통지**가 구분 기준

#### Blocking

> 일련의 작업들에 대해 순차적으로 하나씩 처리하고 완료하는 방식에서 작업의 순서를 보장하기 쉽다.

- 작업이 끝날 때까지 **대기하다가** 즉석에서 **완료 통지를 받는다.**

- 호출된 함수가 자신의 **작업을 모두 마칠 때까지** 호출한 함수에게 제어권을 넘겨주지 않고 **대기하게 만든다.**

#### Non-Blocking

> 여러 작업들이 동시에 일어나는 구조에서 효율적

- 작업의 완료를 나중에 통지 받는다. 작업의 시작 이후 **완료시까지 대기하지 않고, 완료시킨다.** 
  
  - 즉, 내부 동작에 무관하게 작업에 대한 완료를 처리 받음.

- 호출된 함수가 **바로 리턴**해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 **다른 일을 할 수 있는 기회**를 줄 수 있다.


<br>

## 조합 정의

### 블럭/동기 

A가 실행되다가 B라는 일을 수행하는 함수를 호출해서 B를 시작한다. B라는 일이 끝나면 함수를 리턴한다. A와 B는 순차적으로 진행되기 때문에 동기이며,  B라는 일을 하는 함수를 호출하고 그 일이 끝나고 나서야 리턴되므로 블럭된 것이다. 따라서 블럭/동기 


### 블럭/비동기 

어떻게 블럭되었는데 A,B라는 일이 동시에 일어나는가? 설명을 들어보고 이런 경우를 말하는구나라는 "감"을 잡아보자.

일단 A는 B라는 일을 시킨다. 그리고 바로 리턴하고 (여기서는 논블럭)  B는 일을 시작하고, A도 자신의 일을 한다. A는 중간에 B라는 일이 하는 중간 결과를 보고 받아서 처리해야한다. A는 B에게 요청을 해서 중간결과를 기다린다(블록), 요청의 결과를 받고 나서 그 결과를 이용해서 A는 자신의 일을 처리한다. 동시에 B 는 또 자신의 일을 동시에 한다. (비동기) A는 다시 B에게 중간결과를 요청해서 기다린다 (블록) , 요청의 결과를 받고 A는 자신의 일을 , B는 자신의 일을 한다. 반복된다.

이 글을 읽고, 사실 갸우뚱 해야한다. 중간에 블록되는 동안에는 "동기" 라고 말 할 수 있기 때문이다. 즉 어느 한 순간에 대해 해석하자면 틀릴 수도 있는것이다. 즉 처음부터 말해왔듯이 "정답"이 존재하지 않는다. 다만 이런 패턴들이 분명히 사용되고 있구나라고 감을 잡는게 목적이다.


### 논블럭/동기 

이것이 예도 위의 블럭/비동기와 비슷한데 조금 다른 늬앙스에 대해서 "감"을 잡아보자.

이것도 역시 A는 B라는 일을 시킨다. 바로 리턴한다. (논블럭)  B는 일을 시작하는데, A는 자신의 일을 하지 않는다. A의 하는 일이란 그저 B가 하는일을 확인하는 것이다. B가 결과 보고(중간 보고가 아니다) 를 했는지를 확인하는 함수를 호출하고 ,바로 리턴한다 (논블럭) 즉 결과 보고를 받을 때 까지 기다리는게 아니라, 결과 보고가 나왔는지 확인하고 바로 리턴하는 것이다.  이 짓을 계속한다. 즉 함수를 계속 논블럭으로 호출되긴 하나, A는 그저 B를 염탐할 뿐이다. 이 상태를 말한다. 그냥 염탐하지 말고 B가 일을 모두 끝마치고 리턴되길 기다리지 ;;; (그냥 블럭/동기로 하는게 나은 상황이 연출된다) 

이후에 B가 결과보고를 하면,B는 자신의 일이 끝난 것이고 A는 이제서야 자신의 일을 처리하게 된다. 즉 순차적이라는 말이다. 따라서 동기~


### 논블럭/비동기 

간단하다. A는 B의 일을 시작시키고 바로 리턴한다 (논블럭) 그리고 A와B는 각자 자신의 일을 한다 (비동기) 

<br>

## 우체국을 예시를 통한 이해

### 블럭/동기 

우체국에 배달 트럭들이 줄을 서 있다. 우체국에 들어오는 물품들을 싣기 위해서인데,
 
- 1번 트럭이 우체국에 내 것들을 가져와주세요 요청하고 기다린다. (블럭)

- 우체국은 1번 트럭에게 주기 위한 물건들을 찾아서 싣기 시작한다. 

- 2번트럭은 1번트럭에 물건이 다 싣기를 기다린다. (블럭)

- 3번 트럭도 기다린다. (블럭)

- 1번트럭이 물건을 싣고 떠나면, 우체국은 이제 2번 트럭의 물건을 찾아서 싣는다. (동기) 

모든 일들이 순차적으로 일어 난다 (동기) 



### 블럭/비동기 

우체국에 가서 내가 필요한 물품은 무엇이라고 접수원에게 말을 하고 집으로 돌아온다.

- 우체국은 물품을 준비하고, 나는 집에서 집안 청소를 한다. (비동기)

- 우체국에 전화 해서 접수원과 통화한다. 물품이 준비되었냐고 물어본다. 접수원은 준비될 때 까지 기다리라고 한다. 나는 하염없이 기다린다 (블럭)

- 접수원이 준비됬다고 말한다. 나는 트럭을 가지고 우체국으로 가서 물건을 싣고 온다.

- 우체국은 자신의 일을 하고, 나는 싣고 온 물건을 배달한다 (비동기) 

중간에 블럭되는 지점이 있지만, 그 이전과 이후에는 각자 자신의 일을 한다. 



### 논블럭/동기 

우체국에 가서 내가 필요한 물품은 무엇이라고 접수원에게 말을 하고 집으로 돌아온다.

- 우체국은 물품을 준비하고, 나는 전화기를 붙잡는다.

- 우체국에 전화 해서 접수원과 통화한다. 물품이 준비되었냐고 물어본다. 접수원은 안됬다고 말한다. 나는 전화를 바로 끊는다. (논블럭)  

- 전화를 끊고, 집안 청소를 하는게 아니라, 다시 우체국에 전화한다. 안됬다고 하면 바로 끊는다 (논블럭)

- 계속 반복적으로 전화한다 (논블럭이며, 나는 내 일을 하는게 아니라 우체국의 일에 매달리고 있으므로 동기) 

- 이번 전화에는 접수원이 준비됬다고 말한다. 나는 트럭을 가지고 우체국으로 가서 물건을 싣고 온다.

- 나는 싣고 온 물건을 배달한다.

중간 중간 논블럭으로 전화를 바로 끊지만, 끊고 나서 바로 또 전화를 하므로 동기



* 이 경우에 내가 배달하는 동안에는 현실과 좀 다르지만 우체국은 쉰다고 생각 해야한다.  (동기) 



### 논블럭/비동기 

우체국에 가서 내가 필요한 물품은 무엇이라고 접수원에게 말을 하고 트럭을 놓고 집에 온다. (논블럭)
트럭(버퍼) 크기가 크다면 우체국에서 많이 채워 줄 것이다. (하지만 좀 더 시간이 걸리겠지) 

- 우체국은 물품을 준비하고, 나는 집에 와서 내일 을 한다 (비동기)

- 전화 따위는 하지 않는다. 우체국에서 알아서 트럭에 짐을 채워서 나에게 트럭이 준비됬으면 연락 할 것이기 때문이다. 

- 트럭이 가득 찼다고 연락이 왔다. 나는 트럭을 가지고서 배달을 시작하고 우체국은 자신의 일을 한다.

이것이 논블럭/비동기이다. 완전 효율적이지 않는가? 

하지만 이것도 병목지점이 있다. 어디일까? 
그렇다. 이 배달기사는 트럭이 한대 뿐이다. 
트럭이 한대 뿐이기 때문에, 배달하는 동안에는 우체국에서 또 다른 짐을 싣지 못한다.

어떻게 해결 할까? 간단하다. 트럭을 2개 만드는 것이다 (기술적으로 버퍼를 2개)
그러면 한대는 배달하는 동안에 우체국에 다른 한대를 맡겨 놓는 것이다.
이렇게 되면 배달일 끝날 쯤에는 우체국에 가있는 트럭은 가득 차 있을 것이고, 나는 연속적으로 배달을 할 수 있어서 돈을 많이 벌 수 있을 것이다.

여기서 끝이 아니다 병목이 또 하나 있다. 이번엔 무엇인가?
그렇다 배달기사가 하나라는 것이다. 

우체국에서 또 다른 트럭이 벌써 가득 차 있다고 연락이 왔지만, 배달중이라 그것을 처리 할 수가 없다. 
이때 어떻게 해야하나? 
그렇다 배달알바를 구하면 된다. 한대의 트럭이 준비되면 그 트럭이 짐을 3등분해서 배달알바 3명에게 나눠준다. 또 다른 트럭이 준비되면 , 배달알바가 끝난 알바생에게 나눠주거나 또 다른 알바생에게 나눠주면 된다.

일의 크기에 따라서 알바생을 늘리면 되는 것이다. 이 알바생이 소프트웨어에서 무엇일까?
그렇다~~ 멀티쓰레드이다.

비동기 / 싱글쓰레드로 짧게 짧게 일하는 곳 (Node 비동기 서버에서 간단한 리턴만 서비스 하는 곳)에서는 멀티 쓰레드를 굳이 도입하지 않아도 효율적이지만, 백단에서 먼가 해야 할 것이 많다면 (CPU intensive) 이렇게 멀티쓰레드를 추가 해주면 성능이 대폭 올라 갈 것이다.



## 참고 블로그

https://hamait.tistory.com/930

https://blog.naver.com/lifesoft/30015652725
